******
二叉树的前序非递归遍历：(根左右)
遍历指针p，辅助栈s;
while(p不空或s不空)
{
	if(p不空)
	{
		visit(p);
		p进栈;
		p=p->left;
	}
	else
	{
		栈顶元素出栈赋给p;
		p=p->right;
	}
}
******
二叉树的中序非递归遍历：(左根右）
遍历指针p，辅助栈s;
while(p不空或s不空)

{
	if(p不空)
	{
		p进栈;
		p=p->left;
	}
	else
	{
		栈顶元素出栈赋给p;
		visit(p);
		p=p->right;
	}
}
******
二叉树的后序非递归遍历：(左右根）
遍历指针p，辅助指针r记录最近被访问过的节点，辅助栈s;
while(p不空或s不空)
{
	if(p不空)
	{
		p进栈;
		p=p->left;
	}
	else
	{
		p=s.top();
		p=p->right;
		if(p不空且r!=p)  //存在右子树且未被访问过
		{
			p进栈；
			p=p->left;
		}
		else
		{
			p=s.top();
			visit(p);
			栈顶元素出栈；
			r=p;
			p=NULL;
		}
	}
}
******
二叉树的层次遍历：
辅助队列q;
根指针进队列;
while (q不空)
{
	visit(q队首);
	if (队首有左节点)
	{
		左节点进队列;
	}
	if (队首有右节点)
	{
		右节点进队列;
	}
	队首出队列;
}
******
平衡二叉树（AVL）树：
左右子树深度相差不超过1
******
二叉搜索树（二叉查找树）：
左子树的值均小于根节点，右子树的值均大于根节点，左右子树分别也为二叉搜索树。
******
红黑树是一种含有红黑结点并能自平衡的二叉查找树。
性质：
1.结点是红色或黑色；
2.根结点是黑色；
3.每个叶节点（NIL节点，NULL节点）是黑色的；
4.每个红色结点的左右子结点都是黑色；
5.从任一结点到其每个叶子的所有路径都包含相同数目的黑色结点。
红黑树查找性能弱于AVL树，但插入和删除效率优于AVL树，综合性能优于AVL树。
******
b树b+树
应用于数据库索引
为何不用二叉树？
每个节点占用一个盘块的磁盘空间（也就是一页）若使用二叉树的话可能会造成深度比较深，IO次数比较多，影响效率，故使用B树B+树（多路平衡查找树）
B树特征：
1.若根结点不是叶子结点，则 2 <= 根结点的孩子数 <= m；（根结点至少包含一个关键字）（m是阶数）
2.除根结点和叶子结点外，ceil(m/2) <= 其它结点的孩子数 <= m，其包含的关键字数 = 它的孩子数-1；（ceil(x)：返回大于或者等于x的最小整数）
3.所有叶子结点都出现在同一层，ceil(m/2)-1 <= 结点包含的关键字数目 <= m - 1
4.每个结点中的关键字从小到大排列，并且非叶子结点的k-1个关键字，正好是它k个孩子包含的关键字的值域分划，即k个孩子恰好被父节点k-1个关键字划分。
B+树特征：
1.有n棵子树的非叶子结点中含有n个关键字（b树是n-1个），这些关键字不保存数据，只用来索引，所有数据都保存在叶子节点（b树是每个关键字都保存数据）。
2.所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。
3.所有的非叶子结点可以看成是索引部分，结点中仅含其子树中的最大（或最小）关键字。
4.通常在b+树上有两个头指针，一个指向根结点，一个指向关键字最小的叶子结点。
5.同一个数字会在不同节点中重复出现，根节点的最大元素就是b+树的最大元素。
B+树相比于B树的优势：
1.b+树的中间节点不保存数据，所以磁盘页能容纳更多节点元素，更“矮胖”；
2.b+树查询必须查找到叶子节点，b树只要匹配到即可不用管元素位置，因此b+树查找更稳定（并不慢）；
3.对于范围查找来说，b+树只需遍历叶子节点链表即可，b树却需要重复地中序遍历。
4.b树和b+树划分方式不太相同，例如父节点为（8，15）对于b树来说他有3个子节点分别保存小于8，8到15，大于15的关键字，对于b+树来说有2个子节点分别保存小于8和8到15的关键字。
******
冒泡排序
外层循环len,内层循环len-i-1。
时间复杂度：最好O(n)，平均O(n2)，最坏O(n2)
空间复杂度：O(1)
稳定
******
选择排序
void Select(vector<int>& arr)
{
    int len = arr.size();
    for (int i = 0; i < len; i++)         //未排序的第一个元素
    {
        int index = i;
        for (int j = i + 1; j < len; j++)//每次循环选取最小元素
        {
            if (arr[index] > arr[j])
            {
                index = j;                   //记录下标
            }
        }
        int temp = arr[i];               //与当前位置交换
        arr[i] = arr[index];
        arr[index] = temp;
    }
}
时间复杂度：最好O(n2)，平均O(n2)，最坏O(n2)
空间复杂度：O(1)
不稳定
******
插入排序
void Insert(vector<int>& arr)
{
    int len = arr.size();
    for (int i = 0; i < len - 1; i++)        //已排序的最后一个元素
    {
        for (int j = i + 1; j > 0; j--)         //从后向前循环
        {
            if (arr[j] < arr[j - 1])
            {
                int temp = arr[j];              //不合适便向前交换
                arr[j] = arr[j-1];
                arr[j-1] = temp;
            }
            else
            {
                break;                             //找到合适的位置插入退出循环
            }
        }
        
    }
}
时间复杂度：最好O(n)，平均O(n2)，最坏O(n2)
空间复杂度：O(1)
稳定
******
快速排序
void Quick(vector<int>& arr)
{
    int len = arr.size();
    int mid = part(arr, 0, len-1);
    sort(arr, 0, mid - 1);
    sort(arr, mid + 1, len - 1);
}
int part(vector<int>& arr, int l, int r)//分区
{
    if(l==r)
        return l;
    int key = l;
    int i = l;
    int j = r;
    while(i!=j){      //key在左边的i则从右往左判断j，key在右边则从左往右判断i
        if(key==i){
            if(arr[i]>arr[j]){
                swap(arr[i],arr[j]);
                key = j;
            }
            else{
                j--;
            }
        }
        else{
            if(arr[i]>arr[j]){
                swap(m[i],m[j]);
                key = i;
            }
            else{
                i++;
            }
        }
    }
    return key;
}
void sort(vector<int>& arr, int l, int r)//排序
{
    if ( l - r >= 0)
        return;
    int mid = part(arr, l, r);
    sort(arr, l, mid - 1);
    sort(arr, mid + 1, r);
}
时间复杂度：最好O(nlogn)，平均O(nlogn)，最坏O(n2)
空间复杂度：O(1)
不稳定
******
归并排序
void mergesort(arr)
{
	sort(arr,0,len);
}
void sort(arr,int l,int r)
{
	if (l == r)
		return;
	int mid = (l + r) / 2;
	sort(arr, l, mid);
	sort(arr, mid + 1, r);
	merg(arr, l, mid, r);
}
void merg(arr, int l, int mid, int r)
{
	int i = l, j = mid + 1;//归并用到的左右指针
	int temp;//临时数组
	while (两指针未达到边界)
	{
		if (右边小)
		{
			右边进temp;
			右指针后移;
		}
		else
		{
			左边进temp;
			左指针后移;
		}
	}
	将剩余的复制进temp的后边；
	将temp复制进原数组；
}
时间复杂度：最好O(nlogn)，平均O(nlogn)，最坏O(nlogn)
空间复杂度：O(n)
稳定
******
快速选择（求数组中第k大的数）
int quickselect(vector<int>& nums, int left, int right, int k) {
	int pivot = right;
	for (int i = left; i < right; i++) {
		if ((nums[i] - nums[pivot]) * (i - pivot) < 0) {
			swap(nums[i], nums[pivot]);
			pivot = i;
		}
	}
	if (pivot - left + 1 == k) {
		return nums[pivot];
	}
	else if (pivot - left + 1 > k) {
		return quickselect(nums, left, pivot - 1, k);
	}
	else {
		return quickselect(nums, pivot, right, k - pivot + left);
	}
}
平均时间复杂度为O(n)
******
数据量很大时如何排序？例如100GB的数据只有100MB的内存
将数据分成10份，每份100MB，加载到内存里，进行快排，写到10个文件中，这时候可以得到10个有序的100MB文件，然后进行多路归并，每个文件取9MB加载到内存中（留10MB用于储存结果），然后归并出9MB的数组IO到文件中，然后再进行IO把内存中每个数组都补充到9MB大小，接着归并，直到所有的数据都排完。
******
堆（以大顶堆为例）
根据已有数组构建：从第一个非叶子节点开始，将不符合堆定义的元素下沉调整（递归）。
下沉调整：比较当前节点和子节点是否满足堆定义，不符合则交换，然后递归下沉调整被调整过的子节点。
插入：自底向上与父节点比较是否满足堆定义，不满足则交换并继续向上检查，满足则停止。
删除堆顶：将堆顶与堆底元素交换，删除堆底，从堆顶开始下沉调整。
堆排序：先将数组初始化为堆，再每次将堆顶与末尾交换，从堆顶开始下沉调整，注意已经排好的元素不再参与下沉调整。
时间复杂度：最好最坏平均均为O(nlogn)。空间复杂度O(1)。不稳定。
******
哈希算法
将任意大小的数据映射为固定长度的数据
单向算法
一般用于校验，签名，存储
哈希表：
将key值经过哈希函数映射为地址
桶：指地址所指的空间
哈希冲突：不同的key经过哈希函数后映射为相同的地址
解决哈希冲突的方法：
1.开放定址法：按照一定规则向下探测直到遇到空桶。
2.再哈希法：设置不同的哈希函数。
3.链地址法：通过链表将所有相同index的元素串起来。
4.建立公共溢出区：建立一个公共溢出区域，把冲突的元素都放在该溢出区里。
哈希函数的构造方法：
1.直接定址法：取关键字或关键字的某个线性函数值为哈希地址。
2.平方取中法：取关键字平方后的中间几位为哈希地址。
3.除留余数法：对小于哈希表容量的质数取余。哈希桶数一般取质数，对哈希桶数取余，会让哈希表分布比较均匀，减少冲突。
4.随机数法：选择一个随机函数，取关键字的随机函数值为它的哈希地址。适用于关键字长度不等时。

一致性哈希：
解决的是数据和多个服务器节点的存取问题。
传统哈希方法：对数据进行哈希，然后对服务器节点进行求模，然后放进对应的服务器节点中，带来的问题就是当服务器节点增加或者服务器有宕机，就有大规模的数据需要重新哈希迁移。
一致性哈希算法：有一个有2^32个虚拟节点的圆环，先对所有的机器节点进行哈希（例如对ip进行哈希）然后对2^32求模，将机器落在这个圆环的节点上；再对所有的数据key哈希并对2^32求模，如果刚好落在机器上，就存在这个机器上，否则顺时针找到第一个机器存放。
节点增加：增加一个节点，则它的顺时针的下一个节点中存放的数据需要重新哈希，部分数据需要迁移到新节点。
节点删除：将该节点的数据移到顺时针的下一个节点即可。

布隆过滤器：
主要用于判断元素在集合中是否存在，有一个m位的bitarray，有k个哈希函数，对于每个元素，用k个哈希函数进行哈希，将结果对m取模，结果为n，则将bitarray的第n位置为1，则一个元素就有k个1，判断是否存在时，也是相同的操作，如果元素计算出的n位在bitarray中都为1则存在，否则不存在，实际只能确定元素不存在，不能确定元素存在，对于元素存在的判断是有一定误差的。