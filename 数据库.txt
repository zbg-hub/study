绪论：
概念模型：现实到机器的一个中间层次，设计人员和用户进行交流的语言，E-R图表示。
数据模型：1.数据结构2.数据操作3.完整性约束。
常用的数据模型：层次模型，网状模型，关系模型...
层次模型：树；网状模型：图。
关系模型：一张表。
模式和实例：型和值的关系。模式：学生表，实例：2014所有学生记录。
三级模式：内模式，模式，外模式。模式：全部数据的总的逻辑结构；外模式是模式的子集，不同的应用有不同的外模式；内模式：数据的物理结构和存储方式的描述。
二级映射：外模式/模式；模式/内模式。
数据的逻辑独立性：模式改变时，外模式/模式的映像做相应的改变以使外模式不变从而使得基于外模式编写的应用不用改变。
数据的物理独立性：内模式（如存储结构）变化时，通过修改相应的模式/内模式的映像以保证模式的不变。
两种独立性都尽量保证越靠上层越稳定，减小开发难度。


关系数据库：
关系的三类完整性约束：实体完整性，参照完整性，用户定义的完整性。
实体完整性：实体的主属性（码）不能为空。例如学生关系中，姓名和学号不能为空。
参照完整性：例如学生关系中有专业号，这个专业号的取值必须可以在专业这个关系中的专业号中找到。
用户定义的完整性：例如职工年龄<60(退休年龄)。
关系代数：
关系特有的操作：
1.选择：选择出符合某些条件的元组（行）
2.投影：选择出某些列组成新的关系（列）
3.连接：两个关系根据某些条件串接组成一个新关系。
4.除运算：A B C   B C D
               1  2 3   2 3  4       A
               2  3 7 / 3 5  7 =   1
               1  3 5   4 6  8
即A=1在第一个关系中BC的投影完全覆盖了第二个关系中BC的投影。
关系演算：
1.元组关系演算：元组关系演算语言ALPHA
2.域关系演算：域关系演算语言QBE


关系数据库标准语言SQL：
索引的定义：为了加快查询速度而对某一列建立索引。
创建数据库：CREATE DATABASE database-name
删除数据库：drop database dbname
创建模式：create schema"S-T" authorization wang  为用户wang创建模式S-T。
创建新表：create table tabname(列名 类型 [约束条件] [primary key],col2 type2 [not null],..) 
删除新表：drop table tabname
增加一个列：Alter table tabname add column col type
添加主键： Alter table tabname add primary key(col)
删除主键：Alter table tabname drop primary key(col) 
创建索引：create [unique] index idxname on tabname(col)
删除索引：drop index idxname
https://zhuanlan.zhihu.com/p/38354000


数据库事务：
是指逻辑上作为一个整体的若干操作，要么全部执行，要么全部不执行。

事务的ACID四大特性：
原子性(Atomicity):是指事务包含的一系列操作是一个整体不可分割，要么全部执行，要么全部不执行。
一致性(Consistency):1.系统的状态满足数据的完整性约束；2.系统的状态描述现实世界的真实状态。如A向B转账100元，转账前后A与B的账户之和为100元不会变。
隔离性(Isolation):是指并发的事务是独立的，隔离的，一个事务的操作不能干扰另一个事务。
持久性(Durability):是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的。

**数据库三大范式：
第一范式：关系模式中每一个属性都不可以再分。
第二范式：在满足第一范式的基础上，每一列都和主键完全相关，则满足第二范式。例如主键为订单编号和产品编号，产品的出售价格跟主键完全相关，但是订单价格只与订单编号相关，不满足第二范式，应拆分为两个表。
第三范式：在满足第一范式的基础上，关系模式的每一个属性都与主键直接相关而不是间接相关。例如学生表中学生姓名其班主任姓名等与主键学号完全相关，但是其班主任年龄与班主任姓名直接相关，与学号间接相关，则不满足第三范式。

数据库索引：
1. 主键索引：按照主键进行索引。
2. 聚集索引：数据的物理顺序和列值的逻辑顺序相同，子节点保存的是数据本身。（MySQL中主键索引一般为聚集索引）
3. 非聚集索引：数据的物理顺序和列值的逻辑顺序不相同，子节点保存的是指向数据的指针。
3. 联合索引：就是好几个字段组成的索引。

索引越多越好吗？
创建索引和维护索引需要消耗时间和空间，并随着数据量的增加而增加。
对数据进行增，删，改时，索引也需要动态维护

**添加索引原则：
1. 在查询中很少使用或参考的列不应该创建索引
2. 数据值取值很少的列也不应该增加索引
3. 对修改性能的需求远大于检索性能时，不应增加索引

乐观锁和悲观锁：
悲观锁：在写数据前进行加锁。
乐观锁：在写数据前不加锁，在写数据后提交时进行版本判断，判断是否有其他线程修改过数据。

数据库的隔离级别：
1. 读未提交（RU）：存在脏读问题
2. 读已提交（RC）：解决脏读，存在不可重复读和幻读
3. 可重复读（RR）：解决不可重复读，存在幻读
4. 串行化：解决所有问题，但并发性下降

**数据库查询优化：
1. 数据库设计方面：
建立索引
若只含数值信息的字段尽量不要设计为字符型
2. sql语句方面：
where中尽量避免使用!=
where中尽量避免使用or
应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如： 
select id from t where num/2=100 
应改为: 
select id from t where num=100*2
where中尽量用between来代替in

***MyISAM和InnoDB的区别
1. MyISAM不支持事务，InnoDB支持事务
2. InnoDB支持外键，MyISAM不支持
3. MyISAM主键索引是非聚集索引，索引只保存数据文件的地址，数据文件的组织形式的物理顺序与主键的逻辑顺序不一样，InnoDB是聚集索引，子节点保存了数据文件。
4. InnoDB辅助索引子节点保存的是主键索引，MyISAM辅助索引保存的是数据文件的地址，辅助索引和主键索引是独立的，InnoDB通过辅助索引先搜到主键，再通过主键去查询具体的数据。
5. InnoDB不保存表的行数，MyISAM保存表的行数。（InnoDB支持事务，不同的事务在同一时刻看到的表的行数是不同的）。
6. InnoDB支持行级锁和表级锁，MyISAM只支持表级锁。
7. InnoDB必须要有主键，MyISAM可以没有，因为InnoDB数据的组织形式就是通过主键索引（聚集索引）组织的，叶子节点保存数据，所以必须要有一个主键，如果不指定主键的话，会默认将自增id作为主键。

mysql的mvcc机制
多版本并发控制，通过创建数据快照来避免加锁，从而提高并发性。
每一行数据增加一些字段，当前的事务id，回滚版本指针（指向上一个版本），删除标识。
快照readview结构：
当前事务id
活跃事务的最小id
活跃事务的最大id
活跃事务id列表
在RR隔离级别下，如果使用mvcc机制，某一事务的操作：
select：（快照读）
如果是第一次select，则生成一个快照，之后的select使用的是同一个快照
按照记录链表依次查询记录，对于每一个记录，使用快照进行如下判断：
1. 记录的事务id是否小于活跃事务的最小id，如果是，则直接返回，因为说明这条记录的事务已经提交了，对于查询的事务来说一定是可见的，如果大于则
2. 记录的事务id是否大于活跃id的最大值，如果是，则根据回滚指针判断上一个版本的记录，如果不是则
3. 记录的事务id是否在活跃id中，如果不是，说明记录的事务id已经提交了，对于该查询事务来说是可见的，可以直接返回，如果是，则说明该条记录是不可见的，判断上一个版本记录。
insert：（当前读）
添加一条记录，事务id为当前事务id，回滚版本为NULL
delete：（当前读）
将该行记录的删除标识置为1
update：（当前读）
将该行记录拷贝下来，放入undolog中，并将新产生的记录版本号改为当前事务的版本号，回滚指针指向旧的版本，旧版本将删除位变为1，实际就是insert+delete操作。

mvcc可以解决快照读的幻读问题，但不能解决当前读的幻读问题。

间隙锁：为了防止出现当前读的幻读，给一定范围内的索引都加上锁。除了唯一索引上的等值查询要加行锁，其余都需要用到间隙锁。

**redis和mongodb的区别：
1. redis数据全部存在内存，定期写入磁盘，内存不够时，可以用指定的lru算法替换，mongodb数据存在内存，由mmap实现，内存不够时，只将热点数据放入内存，其他数据存在磁盘。
2. redis支持的数据结构丰富，包括hash,set,list等，mongodb数据结构比较单一，但是支持丰富的数据表达，索引。

**redis中的文件事件和时间事件
redis服务器是一个事件驱动程序
文件事件：Redis服务器通过套接字与客户端或其他Redis服务器进行连接，而文件事件就是服务器对套接字操作的抽象，使用IO多路复用来监听不同的套接字。
时间事件：用来完成一些定时操作

***时间事件的分类
定时事件
周期性事件
目前版本的redis只使用周期性事件，没有使用定时事件。
serverCron事件：
更新服务器统计信息如时间，内存占用等
清理过期数据
清理失效客户端
持久化操作
同步主从服务器或集群

***时间事件的属性：
1. id：每个时间事件的标识。
2. when：记录时间事件的到达时间。
3. timeProc：时间事件处理器，一个时间事件到达时服务器调用的处理函数。

**redis为何单线程还很快？
1. 内存读写
2. IO多路复用
3. 单线程避免了线程切换开销，不存在死锁带来的影响。

redis支持的数据类型及底层实现：
redis中key是字符串类型（字节流）value有5种类型：
1. string：redis自己实现的sds，简单动态字符串，对C语言中的char数组做了封装。
2. 列表（list）：双向链表，实现了链表类和链表节点类。
3. 集合（set）：redis自己定义的字典（哈希表），采用hash+链地址解决哈希冲突
4. 有序集合（Zset)：跳表。
5. 哈希类型：字典

跳表：基于链表实现的一种类似“二分”的算法
在原始链表上面一层加一个链表作为索引，索引的next指向下一个索引节点，down指向原始链表的对应节点。可以添加多级索引来提高效率。
原始链表某些节点作为索引节点，索引指针指向下一个索引节点（同一层）。

**为什么用跳表不用平衡树？
1. 内存占用
2. 范围查找性能
3. 代码实现难度

redis的rehash，渐进rehash：
字典中存了两张哈希表（rehash优化）
1. 遇到增删改查操作，判断是否在一轮rehash（index是否为-1）中，如果在，返回需要rehash的index并rehash后放到另一张表里，如果不在，判断是否需要进行扩容或缩容进行新一轮的rehash。
2. 如果要进行新一轮的rehash，返回0，并在之后的增删改查操作中进行rehash，直到一张哈希表清空释放。

**redis的持久化
rdb：通过定期将内存中的数据dump到磁盘中进行持久化，持久化时，fork一个子进程，由子进程来完成。优点：性能好（在持久化时性能会下降）。缺点：有数据丢失的可能。
aof：通过将操作以追加的方式写入文件中，下次启动时，将操作再执行一遍。同步方式有每秒同步，每修改同步。优点是数据完整性好，缺点是性能较差。

分布式相关：
一致性哈希：
解决的是数据和多个服务器节点的存取问题。
传统哈希方法：对数据进行哈希，然后对服务器节点进行求模，然后放进对应的服务器节点中，带来的问题就是当服务器节点增加或者服务器有宕机，就有大规模的数据需要重新哈希迁移。
一致性哈希算法：有一个有2^32个虚拟节点的圆环，先对所有的机器节点进行哈希（例如对ip进行哈希）然后对2^32求模，将机器落在这个圆环的节点上；再对所有的数据key哈希并对2^32求模，如果刚好落在机器上，就存在这个机器上，否则顺时针找到第一个机器存放。
节点增加：增加一个节点，则它的顺时针的下一个节点中存放的数据需要重新哈希，部分数据需要迁移到新节点。
节点删除：将该节点的数据移到顺时针的下一个节点即可。

redis中的做法：
每个节点负责固定数量的哈希槽，对数据哈希后看落到哪个哈希槽里，放入对应的节点中。
增加节点：将每个节点都分出一部分哈希槽给新的节点，每个节点都要迁移一部分数据。
删除节点：将删除节点的哈希槽平分给其他节点，并做数据迁移。

一致性哈希和哈希槽的比较：
对于增删节点，哈希槽迁移的数据总量较多，且迁移涉及到每个节点，一致性哈希迁移的数据量少，只涉及一个节点，但是哈希槽迁移数据后数据分布比较均匀，一致性哈希有可能会造成节点数据量不均匀。

缓存雪崩，缓存穿透，缓存击穿
缓存雪崩：
同一时间，大量缓存都过期，导致大量查询直接去查数据库，给数据库带来巨大压力。解决方法：过期时间随机化；如果是分布式存储，尽量将缓存分布在不同的节点上；设置热点数据永不过期。
缓存穿透：
指一个数据缓存中没有，数据库中也没有，过多的查询会给数据库带来压力。解决方法：设置布隆过滤器，将数据库中不存在的查询过滤掉。
布隆过滤器：
主要用于判断元素在集合中是否存在，有一个m位的bitarray，有k个哈希函数，对于每个元素，用k个哈希函数进行哈希，将结果对m取模，结果为n，则将bitarray的第n位置为1，则一个元素就有k个1，判断是否存在时，也是相同的操作，如果元素计算出的n位在bitarray中都为1则存在，否则不存在，实际只能确定元素不存在，不能确定元素存在，对于元素存在的判断是有一定误差的。
缓存击穿：
某一个key并发量比较高，如果这个key对应的数据缓存过期了，都会去查询数据库而带来巨大压力。解决方法：缓存失效后，第一个访问数据库的线程给这个key加一个锁，其他线程等一段时间去访问更新后的缓存。

缓存与数据库的一致性：
Cache Aside：先更新数据库，让缓存失效。
可能出现的问题：一个读操作，没有命中缓存，去数据库中找数据，此时一个写操作，更新了数据库，并使缓存失效，此时读操作把旧数据写入到缓存中，出现了不一致，出现的概率较低。
