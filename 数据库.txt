绪论：
概念模型：现实到机器的一个中间层次，设计人员和用户进行交流的语言，E-R图表示。
数据模型：1.数据结构2.数据操作3.完整性约束。
常用的数据模型：层次模型，网状模型，关系模型...
层次模型：树；网状模型：图。
关系模型：一张表。
模式和实例：型和值的关系。模式：学生表，实例：2014所有学生记录。
三级模式：内模式，模式，外模式。模式：全部数据的总的逻辑结构；外模式是模式的子集，不同的应用有不同的外模式；内模式：数据的物理结构和存储方式的描述。
二级映射：外模式/模式；模式/内模式。
数据的逻辑独立性：模式改变时，外模式/模式的映像做相应的改变以使外模式不变从而使得基于外模式编写的应用不用改变。
数据的物理独立性：内模式（如存储结构）变化时，通过修改相应的模式/内模式的映像以保证模式的不变。
两种独立性都尽量保证越靠上层越稳定，减小开发难度。


关系数据库：
关系的三类完整性约束：实体完整性，参照完整性，用户定义的完整性。
实体完整性：实体的主属性（码）不能为空。例如学生关系中，姓名和学号不能为空。
参照完整性：例如学生关系中有专业号，这个专业号的取值必须可以在专业这个关系中的专业号中找到。
用户定义的完整性：例如职工年龄<60(退休年龄)。
关系代数：
关系特有的操作：
1.选择：选择出符合某些条件的元组（行）
2.投影：选择出某些列组成新的关系（列）
3.连接：两个关系根据某些条件串接组成一个新关系。
4.除运算：A B C   B C D
               1  2 3   2 3  4       A
               2  3 7 / 3 5  7 =   1
               1  3 5   4 6  8
即A=1在第一个关系中BC的投影完全覆盖了第二个关系中BC的投影。
关系演算：
1.元组关系演算：元组关系演算语言ALPHA
2.域关系演算：域关系演算语言QBE


关系数据库标准语言SQL：
索引的定义：为了加快查询速度而对某一列建立索引。
创建数据库：CREATE DATABASE database-name
删除数据库：drop database dbname
创建模式：create schema"S-T" authorization wang  为用户wang创建模式S-T。
创建新表：create table tabname(列名 类型 [约束条件] [primary key],col2 type2 [not null],..) 
删除新表：drop table tabname
增加一个列：Alter table tabname add column col type
添加主键： Alter table tabname add primary key(col)
删除主键：Alter table tabname drop primary key(col) 
创建索引：create [unique] index idxname on tabname(col)
删除索引：drop index idxname
https://zhuanlan.zhihu.com/p/38354000


数据库事务：
是指逻辑上作为一个整体的若干操作，要么全部执行，要么全部不执行。

事务的ACID四大特性：
原子性(Atomicity):是指事务包含的一系列操作是一个整体不可分割，要么全部执行，要么全部不执行。
一致性(Consistency):1.系统的状态满足数据的完整性约束；2.系统的状态描述现实世界的真实状态。如A向B转账100元，转账前后A与B的账户之和为100元不会变。
隔离性(Isolation):是指并发的事务是独立的，隔离的，一个事务的操作不能干扰另一个事务。
持久性(Durability):是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的。

数据库三大范式：
第一范式：关系模式中每一个属性都不可以再分。
第二范式：在满足第一范式的基础上，每一列都和主键完全相关，则满足第二范式。例如主键为订单编号和产品编号，产品的出售价格跟主键完全相关，但是订单价格只与订单编号相关，不满足第二范式，应拆分为两个表。
第三范式：在满足第一范式的基础上，关系模式的每一个属性都与主键直接相关而不是间接相关。例如学生表中学生姓名其班主任姓名等与主键学号完全相关，但是其班主任年龄与班主任姓名直接相关，与学号间接相关，则不满足第三范式。

数据库索引：
1. 主键索引：按照主键进行索引。
2. 聚集索引：数据的物理顺序和列值的逻辑顺序相同，子节点保存的是数据本身。（MySQL中主键索引一般为聚集索引）
3. 非聚集索引：数据的物理顺序和列值的逻辑顺序不相同，子节点保存的是指向数据的指针。
3. 联合索引：就是好几个字段组成的索引。

索引越多越好吗？
创建索引和维护索引需要消耗时间和空间，并随着数据量的增加而增加。
对数据进行增，删，改时，索引也需要动态维护

添加索引原则：
1. 在查询中很少使用或参考的列不应该创建索引
2. 数据值取值很少的列也不应该增加索引
3. 对修改性能的需求远大于检索性能时，不应增加索引

乐观锁和悲观锁：
悲观锁：在写数据前进行加锁。
乐观锁：在写数据前不加锁，在写数据后提交时进行版本判断，判断是否有其他线程修改过数据。

数据库的隔离级别：
1. 读未提交（RU）：存在脏读问题
2. 读已提交（RC）：解决脏读，存在不可重复读和幻读
3. 可重复读（RR）：解决不可重复读，存在幻读
4. 串行化：解决所有问题，但并发性下降

数据库查询优化：
1. 数据库设计方面：
建立索引
若只含数值信息的字段尽量不要设计为字符型
2. sql语句方面：
where中尽量避免使用!=
where中尽量避免使用or
应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如： 
select id from t where num/2=100 
应改为: 
select id from t where num=100*2

MyISAM和InnoDB的区别
1. MyISAM不支持事务，InnoDB支持事务
2. InnoDB支持外键，MyISAM不支持
3. MyISAM主键索引是非聚集索引，索引只保存数据文件的地址，数据文件的组织形式的物理顺序与主键的逻辑顺序不一样，InnoDB是聚集索引，子节点保存了数据文件。
4. InnoDB辅助索引子节点保存的是主键索引，MyISAM辅助索引保存的是数据文件的地址，辅助索引和主键索引是独立的，InnoDB通过辅助索引先搜到主键，再通过主键去查询具体的数据。
5. InnoDB不保存表的行数，MyISAM保存表的行数。（InnoDB支持事务，不同的事务在同一时刻看到的表的行数是不同的）。
6. InnoDB支持行级锁和表级锁，MyISAM只支持表级锁。
7. InnoDB必须要有主键，MyISAM可以没有，因为InnoDB数据的组织形式就是通过主键索引（聚集索引）组织的，叶子节点保存数据，所以必须要有一个主键，如果不指定主键的话，会默认将自增id作为主键。

mysql的mvcc机制
多版本并发控制，通过创建数据快照来避免加锁，从而提高并发性。
每一行数据增加一些字段，当前的事务id，回滚版本指针（指向上一个版本），删除标识。
在RR隔离级别下，如果使用mvcc机制，某一事务的操作：
select：
查询快照，满足
1. 快照的事务id<=该事务的事务id（保证读到的数据都是前面的事务或自己更新的）
2. 快照的回滚版本事务id>该事务的事务id或回滚版本为NULL（保证不会读到失效数据）
insert：
添加一条记录，事务id为当前事务id，回滚版本为NULL
delete:
将该行记录的删除标识置为1
update:
将该行记录拷贝下来，放入undolog中，并将新产生的记录版本号改为当前事务的版本号，回滚指针指向旧的版本。

redis和mongodb的区别：
1. redis数据全部存在内存，定期写入磁盘，内存不够时，可以用指定的lru算法替换，mongodb数据存在内存，由mmap实现，内存不够时，只将热点数据放入内存，其他数据存在磁盘。
2. redis支持的数据结构丰富，包括hash,set,list等，mongodb数据结构比较单一，但是支持丰富的数据表达，索引。

redis中的文件事件和时间事件
redis服务器是一个事件驱动程序
文件事件：Redis服务器通过套接字与客户端或其他Redis服务器进行连接，而文件事件就是服务器对套接字操作的抽象，使用IO多路复用来监听不同的套接字。
时间事件：用来完成一些定时操作

时间事件的分类
定时事件
周期性事件
目前版本的redis只使用周期性事件，没有使用定时事件。
serverCron事件：
更新服务器统计信息如时间，内存占用等
清理过期数据
清理失效客户端
持久化操作
同步主从服务器或集群

时间事件的属性：
1. id：每个时间事件的标识。
2. when：记录时间事件的到达时间。
3. timeProc：时间事件处理器，一个时间事件到达时服务器调用的处理函数。

redis为何单线程还很快？
1. 内存读写
2. IO多路复用
3. 单线程避免了线程切换开销，不存在死锁带来的影响。

redis支持的数据类型及底层实现：
redis中key是字符串类型（字节流）value有5种类型：
1. string：redis自己实现的sds，简单动态字符串，对C语言中的char数组做了封装。
2. 列表（list）：双向链表，实现了链表类和链表节点类。
3. 集合（set）：redis自己定义的字典（哈希表），采用hash+链地址解决哈希冲突
4. 有序集合（Zset)：跳表。
5. 哈希类型：字典

跳表：基于链表实现的一种类似“二分”的算法
在原始链表上面一层加一个链表作为索引，索引的next指向下一个索引节点，down指向原始链表的对应节点。可以添加多级索引来提高效率。
原始链表某些节点作为索引节点，索引指针指向下一个索引节点（同一层）。

为什么用跳表不用平衡树？
1. 内存占用
2. 范围查找性能
3. 代码实现难度

redis的rehash，渐进rehash：
字典中存了两张哈希表（rehash优化）
1. 遇到增删改查操作，判断是否在一轮rehash（index是否为-1）中，如果在，返回需要rehash的index并rehash后放到另一张表里，如果不在，判断是否需要进行扩容或缩容进行新一轮的rehash。
2. 如果要进行新一轮的rehash，返回0，并在之后的增删改查操作中进行rehash，直到一张哈希表清空释放。

redis的持久化
rdb：通过定期将内存中的数据dump到磁盘中进行持久化，持久化时，fork一个子进程，由子进程来完成。优点：性能好（在持久化时性能会下降）。缺点：有数据丢失的可能。
aof：通过将操作以追加的方式写入文件中，下次启动时，将操作再执行一遍。同步方式有每秒同步，每修改同步。优点是数据完整性好，缺点是性能较差。

缓存雪崩，缓存穿透，缓存击穿
缓存雪崩：
同一时间，大量缓存都过期，导致大量查询直接去查数据库，给数据库和内存带来巨大压力。解决方法：过期时间随机化；如果是分布式存储，尽量将缓存分布在不同的节点上；设置热点数据永不过期。
缓存穿透：
指一个数据缓存中没有，数据库中也没有，过多的查询会给数据库带来压力。解决方法：设置布隆过滤器，将数据库中不存在的查询过滤掉。
布隆过滤器：
主要用于判断元素在集合中是否存在，有一个m位的bitarray，有k个哈希函数，对于每个元素，用k个哈希函数进行哈希，将结果对m取模，结果为n，则将bitarray的第n位置为1，则一个元素就有k个1，判断是否存在时，也是相同的操作，如果元素计算出的n位在bitarray中都为1则存在，否则不存在，实际只能确定元素不存在，不能确定元素存在，对于元素存在的判断是有一定误差的。
缓存击穿：
某一个key并发量比较高，如果这个key对应的数据缓存过期了，都会去查询数据库而带来巨大压力。解决方法：缓存失效后，第一个访问数据库的线程给这个key加一个锁，其他线程等一段时间去访问更新后的缓存。