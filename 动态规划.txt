力扣dp汇总：https://leetcode-cn.com/circle/article/NfHhXD/
5.最长回文子串
P[i][j]表示s[i]到s[j]是否为回文子串，1为是，0为否。
则P[i][j]=P[i+1][j-1]&&(s[i]==s[j])
然后遍历一遍找出j-i最大的P[i][j]。
10. 正则表达式匹配
dp[i][j]代表s的前i个能否和p的前j个匹配（s为字符串，p为模式）
状态转移方程                 dp[i-1][j-1], match(s[i-1],p[j-1])
              if(p(j-1)!='*')={
dp[i][j]={                       false,otherwise
                                 dp[i-1][j]ordp[i][j-2], match(s[i-1],p[j-2])
              otherwise={
                                 dp[i][j-2], otherwise
解释：match(s[i],p[j])当s[i]==p[j]或p[j]=='.'为1
当p(j-1)='*'时，'*'代替的是p(j-2)所以需要看 match(s[i-1],p[j-2])来确定'*'能否将s[i-1]包含进去，如果可以包含进去，则有两种可能，一种是'*'不省略，则看dp[i-1][j]，如果s的前i-1个可以和p的前j个匹配，那即使再加个s[i-1]（第i个）也可以被*包含进去。第二种是*省略，则看dp[i][j-2]。
若match(s[i-1],p[j-2])不成立，则*必须省略，看dp[i][j-2]。
32.最长有效括号
栈法：
-1先入栈，遇到'('，将序号入栈，遇到')'，将栈顶出栈，若此时栈空则将序号入栈，否则用当前序号-栈顶元素得出该有效子字符串的长度，并和最大长度相比较得到最大长度。核心思路是保证栈顶元素为非有效子字符串的最后一位的序号。
动规：
dp[i]表示以s[i]结尾的有效子字符串长度。
初始化都为0；
若s[i]==')';
若s[i-1]=='('，dp[i]=dp[i-2]+2;
若s[i-1]==')'，若s[i-dp[i-1]-1]=='('，则dp[i]=(i - dp[i - 1] >= 2?dp[i - dp[i - 1] - 2]:0)+dp[i - 1] + 2。注意数组越界问题。
53.最大子序和
dp[i]表示以i为终点的连续最大和（连续），则dp[i]=array[i](dp[i-1]<=0)或array[i]+dp[i-1](dp[i-1]>0),结果取dp[i]中最大值。
62.不同路径
dp[i][j]表示(0,0)到(i,j)的路径
状态转移方程：dp[i][j]=dp[i-1][j]+dp[i][j-1]
63.不同路径II
若(i,j)为障碍，则dp[i][j]=0
64. 最小路径和
dp[i][j]表示从(0,0)到(i,j)的最小路径和
状态转移方程：dp[i][j]=min(dp[i-1][j],dp[i][j-1])+grid[i][j]，注意dp数组初始化。
72.编辑距离
dp[i][j]表示s1[0...i]转变为s2[0...j]所需要的最小的操作。
转移方程：如果s1[i]==s2[j]，那么dp[i][j]=dp[i-1][j-1]；
如果s1[i]!=s2[j]，则dp[i][j]=min(dp[i-1][j-1],dp[i][j-1],dp[i-1][j])+1
dp[i-1][j-1]到dp[i][j]需要进行替换操作
dp[i][j-1]到dp[i][j]需要进行插入操作
dp[i-1][j]到dp[i][j]需要进行删除操作
115. 不同的子序列
dp[i][j]表示s(0..i)中t(0..j)出现的次数
状态转移：
dp[i][j] = (j > 0 ? dp[i - 1][j - 1] : 1) + dp[i - 1][j] （s[i]==t[j])（当j==0时，由于s[i]==t[j]，所以至少会出现1次）
dp[i][j] = dp[i - 1][j]  (s[i]!=t[j])
注意中间某些dp会出现超越int的情况。
139. 单词拆分
dp[i]表示前i个字符是否合法。
状态转移：j（从0到i-1遍历）表示分割点，将前i个字符分割为两部分，若有某个j使得dp[j]&&check(j,i-1)为真则dp[i]为真。其中check(j,i-1)表示s(j...i-1)是否存在于wordDict中。
注意剪枝可提高效率，枚举j时倒着枚举，当发现s(j...i-1)已经超过wordDict中最长单词的长度便可停止枚举。
152. 乘积最大子数组
dp[i]表示以i结尾的子数组的乘积的最大值
状态转移：dp[i]=max(dp[i-1]xnums[i],nums[i])，遍历一遍求最大值。
错！
(5,6,-3,4,-3)，dp[i]为(5,30,-3,4,-3)求得最大值为30，实际最大值为数组全部元素的乘积，因为当nums[i]为负时，要求最大值，希望以i-1结尾的子数组中有一个最小的负数来抵消，所以该算法有问题。正确做法：维护两个数组
maxdp[i]表示以i结尾的子数组的乘积的最大值，mindp[i]表示以i结尾的子数组的乘积的最小值
状态转移：maxdp[i]=max(maxdp[i-1]xnums[i],mindp[i-1]xnums[i],nums[i])
mindp[i]=min(maxdp[i-1]xnums[i],mindp[i-1]xnums[i],nums[i])
遍历一遍求最大的maxdp[i]。
198. 打家劫舍
dp[i]表示从0到i房间能打劫到的最大值
对于第i个房间，有两种选择，打劫i，不打劫i，若打劫i，则打劫到的最大金额为dp[i-2]+nums[i]，若不打劫i，则最大金额为dp[i-1]，所以状态转移为：dp[i]=max(dp[i-2]+nums[i],dp[i-1])。
221. 最大正方形
dp[i][j]表示以matrix[i][j]为右下角的最大正方形的边长
dp[i-1][j-1]表示对角线能延伸的范围，dp[i][j-1]表示宽能延伸的范围，dp[i-1][j]表示高能延伸的范围，则以matrix[i][j]为右下角能延伸的范围为三者的最小值，如果matrix[i][j]=0，则dp[i][j]=0。
状态转移：if(matrix[i][j]=1)：dp[i][j]=min(dp[i-1][j-1],dp[i][j-1],dp[i-1][j])+1
else：dp[i][j]=0。
279. 完全平方数
动态规划：
dp[i]表示i可以分解成的最小完全平方和的个数
状态转移：dp[i]=min(dp[i-k])+1，k为小于i的完全平方数。最后dp[n]即为答案，时间复杂度为nx根号n。
300.最长上升子序列
dp[i]表示以nums[i]结尾的最长上升子序列长度（包含nums[i]），则dp[i]=max(dp[j])+1,0<=j<i，且nums[j]<nums[i]。
309. 最佳买卖股票时机含冷冻期
dp[i][0]表示该天持有一支股票的累计最大利润
dp[i][1]表示该天不持有股票且是i天卖的
dp[i][2]表示该天不持有股票且不是i天卖的。
状态转移：dp[i][0]=max(dp[i-1],dp[i-1][2]-prices[i])
dp[i][1]=dp[i-1][0]+prices[i]
dp[i][2]=max(dp[i-1][1],dp[i-1][2])
312. 戳气球
dp[i][j]表示开区间(i,j)中填满元素可获得的最大收益（不能是闭区间，因为填i和j的时候也有收益，而填i，j的收益又无法确定）
状态转移：dp[i][j]=max(nums[i]xnums[mid]xnums[j]+dp[i][mid]+dp[mid][j])，if(j-i>1) （mid为第一次填的位置）
dp[i][j]=0，if(j-i<=1)
注意填dp的顺序，以及j-i<=1的地方就不用填了。
322. 零钱兑换
动态规划：dp[i]表示amount=i时所需要的最小的硬币个数。
状态转移：dp[i]=min(dp[i-c]+1)(c in range coins)
注意初始化，以及在计算dp[i]时，若dp[i-c]<0为无效的，若发现这一轮所有的dp[i-c]都是无效的则dp[i]=-1。
337. 打家劫舍 III
动态规划+后序遍历
f[i]表示选择i节点，i节点及子树所能获得的最大收益。
g[i]表示不选择i节点，i节点及子树所能获得的最大收益。
状态转移：
f[i]=g[i->left]+g[i->right]+i->val
g[i]=max(f[i->left],g[i->left])+max(f[i->right],g[i->right])
后序遍历一遍求max(f[root],g[root])
474. 一和零
此题是01背包问题的变形
dp[i][j][k]表示到下标i，有j个0，k个1，可以容纳的最多的str个数
状态转移：
dp[i][j][k]=max(dp[i-1][j-strs[i]中0的个数][k-strs[i]中1的个数]+1,dp[i-1][j][k])（注意越界时为0）
494. 目标和
此题实际上是求对于一个数组，能不能分解为两堆使得sumA-sumB=S，这道题可以转化为01背包问题，两边同时加上数组所有元素的和sum则变为2sumA=S+sum，即sumA=(S+sum)/2，变成能找到多少个子集，使得子集和为(S+sum)/2。
dp[i][j]表示到下标i，有多少种子集和为j。
dp[i][j] = (j < nums[i] ? 0 : dp[i - 1][j - nums[i]]) + dp[i - 1][j]  //下标为i的元素是否取
dp[0][0]=1，注意若nums[0]=0(空集），则dp[0]=2（空集和取0）。
注意特判。
1143.最长公共子序列
dp[i][j]表示s1[0...i]和s2[0...j]的最长公共子序列长度。
转移方程：如果s1[i]==s2[j]，说明这两个为公共最长子序列的末尾，此时dp[i][j]=dp[i-1][j-1]+1;
如果s1[i]!=s2[j]，则s1[i]和s2[j]至少有一个不在公共子序列中，如果s1[i]不在，则dp[i][j]=dp[i-1][j]，如果s2[j]不在则dp[i][j]=dp[i][j-1]，故dp[i][j]=max(dp[i-1][j],dp[i][j-1])。
最长公共子串
dp[i][j]表示s1[0...i]和s2[0...j]的最长公共子串长度（必须以s1[i]和s2[j]结尾）
状态转移：当i=0或j=0时，如果是s1[i]==s2[j]则dp[i][j]=1，否则dp[i][j]=0；
当i，j都不为0时，如果是s1[i]==s2[j]则dp[i][j]=dp[i-1][j-1]+1，否则dp[i][j]=0。
面试题 08.13. 堆箱子
首先按照某一个特征进行排序（例如宽度），可以减少循环量，假设排序后变为sorted_box
dp[i]表示以sorted_box[i]为底可以堆成的最大高度。
状态转移：
dp[i] = max(dp[j] + sorted_box[i][2], dp[i])，其中j满足sorted_box[j]可以放在sorted[i]上面。
最后的结果为dp[i]中最大的一个。
面试题 17.24. 最大子矩阵
用i和j枚举矩阵的上下边界，可将该问题退化为53.最大子序和，数组元素的每一列就是以i，j为上下边界的矩阵该列所有元素的和，注意要记录最大字序和的左右边界，当dp[k-1]<0时，就要更新可能的左边界lefttemp，当发现当前的dp大于当前的最大和时，要更新左右边界leftmax=lefttemp，rightmax=k。