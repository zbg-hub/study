进程和线程的区别：
1.进程是对运行时程序的封装，线程是进程的子任务。
2.进程是资源分配的最小单位，线程是cpu调度的最小单位
3.进程有自己独立的地址空间，有自己的堆栈段，线程使用相同的地址空间，共享进程的数据，但是有自己的局部变量，有自己独立的栈空间。
3.线程之间的通信方便的多，因为共享进程的全局静态变量，进程之间的通信IPC
5.一个进程挂了不会影响其他进程因为进程拥有自己的独立地址空间，一个线程挂了可能会影响到其他线程。

cpu进程线程调度策略？

进程的通信：
管道pipe：系统内核在内核缓冲区开辟的一个环形队列（也是一个文件，对管道的操作都是文件操作），一个读端一个写端，只能在有亲缘关系的进程间使用，半双工。
有名管道FIFO：可在无亲缘关系的进程间使用。
消息队列MessageQueue：消息具有特定的格式，独立于发送和接收进程。
共享存储：允许多个进程访问同一片内存，适合于通信数据量比较大的情况，但需要设置信号与信号量等来保证安全或者同步问题，不需要内核的拷贝，效率很高。
信号量Semaphore和信号Signal：和线程中类似。
套接字Socket：用于不同主机之间进程的通信。

*进程的状态：
创建：进程正在被创建
就绪：进程加入到就绪队列等待cpu调度
执行：进程正在被运行
阻塞：由于某种原因，暂时不能运行，如等待资源，等待IO，等待设备。
终止：进程运行完毕

并发和并行的区别：
并发：宏观上的并行，微观上的串行。
并行：严格的同时进行，例如多处理器多线程。

*进程调度算法：
1. 先来先服务 有利于CPU密集型作业，不利于IO密集型作业。
2. 短作业优先 容易出现饥饿现象，即长作业长时间得不到调度。
3. 高响应比优先 综合先来先服务和短作业优先的调度算法。
4. 时间片轮转算法


什么是线程安全：
多线程编程中对于公共资源的不恰当使用带来的数据污染问题。

线程间的通信：
临界区：每个进程中访问临界资源的那段代码称为临界区。
互斥量：也叫互斥锁，通过加锁，将对共享的资源的使用变为互斥操作，避免时间上的错误。
信号量：对数量有限的资源的保护，限制同一时刻访问该资源的最大线程数。
信号：用来通知系统资源状态改变。

线程同步方式：
信号量：取自然数，对数量有限的资源的保护，限制同一时刻访问该资源的最大线程数，并且只支持两种操作即PV操作。
P(S)，检查信号量S，如果大于0则减一，然后访问临界资源，如果等于0则将线程挂起。
V(S)，检查是否有等待的线程，如果有将该线程唤起，然后将S+1，否则直接将S+1。
互斥量：即信号量取0和1，避免脏读脏写。
条件变量：条件变量是当某个共享数据达到某个值时，唤醒等待这个共享数据的一个/多个线程，就是一种信号机制。
读写锁：允许多个线程做读操作，只允许一个线程做写操作，当有线程进行写操作时，不允许进行读操作。
自旋锁：当获取锁失败时，不会进入睡眠，而是原地旋转（循环监听），直到锁被释放。（当竞争不激烈时，使用自选锁效率会更高）。
RCU：另一种读写锁，读不需要锁，写时将数据拷贝出来进行写，但要对其他写者上锁，没有死锁问题。

***手写PV操作实现生产者消费者？
full = 0;
empty = n;
mutex = 1;

read() {
	while (1) {
		P(full);
		P(mutex);
		read;
		V(mutex);
		V(empty);
	}
}

write() {
	while (1) {
		P(empty);
		P(mutex);
		write;
		V(mutex);
		V(full);
	}
}

*死锁产生的必要条件：
互斥条件：一个资源每次只能被一个进程使用。
请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
不剥夺条件：进程已获得的资源，在未使用之前，不能强行剥夺。
循环等待条件：若干进程之间形成一种头尾相接的循环等待资源的关系。

**死锁的预防，避免，检测及解除？
预防：破坏死锁产生的条件。
避免：资源分配过程中用某种方法防止系统进入不安全状态，从而避免死锁。
检测及解除：允许进程在运行过程中发生死锁，通过检测机构检测出来并采取措施解除死锁。
死锁的检测：死锁定理：死锁的条件为当且仅当资源分配图是不可完全简化的。
死锁的解除：
1. 资源剥夺法
2. 撤销进程法
3. 进程回退法

常用的线程模型：
1、Future模型
该模型通常在使用的时候需要结合Callable接口配合使用。
Future是把结果放在将来获取，当前主线程并不急于获取处理结果。允许子线程先进行处理一段时间，处理结束之后就把结果保存下来，当主线程需要使用的时候再向子线程索取。
Callable是类似于Runnable的接口，其中call方法类似于run方法，所不同的是run方法不能抛出受检异常没有返回值，而call方法则可以抛出受检异常并可设置返回值。两者的方法体都是线程执行体。
2、fork&join模型
该模型包含递归思想和回溯思想，递归用来拆分任务，回溯用合并结果。可以用来处理一些可以进行拆分的大任务。其主要是把一个大任务逐级拆分为多个子任务，然后分别在子线程中执行，当每个子线程执行结束之后逐级回溯，返回结果进行汇总合并，最终得出想要的结果。
这里模拟一个摘苹果的场景：有100棵苹果树，每棵苹果树有10个苹果，现在要把他们摘下来。为了节约时间，规定每个线程最多只能摘10棵苹树以便于节约时间。各个线程摘完之后汇总计算总苹果树。
3、actor模型
actor模型属于一种基于消息传递机制并行任务处理思想，它以消息的形式来进行线程间数据传输，避免了全局变量的使用，进而避免了数据同步错误的隐患。actor在接受到消息之后可以自己进行处理，也可以继续传递（分发）给其它actor进行处理。在使用actor模型的时候需要使用第三方Akka提供的框架。
4、生产者消费者模型
生产者消费者模型都比较熟悉，其核心是使用一个缓存来保存任务。开启一个/多个线程来生产任务，然后再开启一个/多个来从缓存中取出任务进行处理。这样的好处是任务的生成和处理分隔开，生产者不需要处理任务，只负责生成任务然后保存到缓存。而消费者只需要从缓存中取出任务进行处理。使用的时候可以根据任务的生成情况和处理情况开启不同的线程来处理。比如，生成的任务速度较快，那么就可以灵活的多开启几个消费者线程进行处理，这样就可以避免任务的处理响应缓慢的问题。
5、master-worker模型
master-worker模型类似于任务分发策略，开启一个master线程接收任务，然后在master中根据任务的具体情况进行分发给其它worker子线程，然后由子线程处理任务。如需返回结果，则worker处理结束之后把处理结果返回给master。

单核cpu有必要使用多线程吗？
一个任务分为计算+io，只有计算才会用到cpu，所以即使是单核，如果是io密集型作业，可以开多个线程，在其他线程由于io而阻塞时，还可以有一个线程使用cpu进行计算。

协程：比线程更轻量级，但不是一个线程，由用户自己管理而不是系统，协程其实就是一个子程序（函数），内部可以中断，然后转而执行别的子程序，在适当的时候再返回来接着执行，协程之间的互相切换没有线程之间切换的开销大。支持协程的语言：go,python等。


*内存管理：
连续内存管理：每个进程的内存空间都是连续的
非连续内存管理：页式内存管理，段式内存管理，段页式内存管理
页式内存管理：
根据是否将所有页面都装入内存分为基本分页存储管理和请求分页存储管理。
逻辑地址结构：页号|页内偏移
页表：页号，块号的映射表。
快表：
时间局部性：如果执行了程序中的某条指令或使用了某些数据，那么不久之后很可能还要执行该指令或使用该数据。
空间局部性：程序访问了某个存储单元，不久之后附近的存储单元也会被访问。
将页表的一部分放入高速缓存中(页表在内存中)，从而提高访问页表的速度。
多级页表：
单级页表存在的问题：页表项太多，且需要连续分配。
两级页表的地址结构：一级页号|二级页号|页内偏移
虚拟内存：请求分页存储管理
相比于基本分页管理的页表，请求分页管理的页表项多了一些字段，例如状态位，修改位等等。
页面置换算法：
最佳置换算法OPT:每次淘汰的都是之后用不使用或者长时间不使用的页面(难以实现)。
先进先出置换算法(FIFO):每次淘汰的页面是最早进入内存的页面，会产生Belady异常，即为进程分配的物理块增加时，缺页不减反增。
最近最久未使用(LRU):每次淘汰的页面为最近最久未使用的页面
时钟置换算法(CLOCK)
LRU-k：解决LRU缓存污染问题：两个LRU队列，一个队列为访问次数不到k次的，一个是访问次数k次以上的，两个队列都按照LRU进行淘汰，put时检查是否存在，不存在直接put进不到k次的队列，存在用LRU算法进行更新。

字节对齐，结构体对齐：
例如int型的数据，需要把这种数据尽量放在4的倍数的起始的地址上，可以使cpu的访问效率提高，否则可能会造成多次访问内存造成效率低下。

*类的内存分布：
static成员变量：在类定义时进内存，所有对象共享，分配内存先于实例化，存储在全局区。
static成员函数：在类定义时进内存，代码在代码区，所有对象共享。
普通成员函数：在类定义时就进内存，所有对象共享一个代码段，不额外消耗对象的内存。
static成员函数和普通成员函数的区别：都是共享一段代码，且分配内存的时机都是在实例化之前，但是普通成员函数有个默认参数this指向具体调用它的对象，static没有也不能调用this指针，静态成员函数可以先于实例化执行，但是只能引用静态成员变量和静态方法。
实例化后的对象的内存分布：
指向对象的指针在栈区，指向的对象在堆区，高地址为该类的虚表指针，低地址为成员变量内存（成员函数在代码段）。虚表指针指向该类的虚函数表，虚函数表在全局只读data段，虚函数表里是该子类的虚方法的地址（指针）。如果有继承关系的话，高地址为子类的虚表指针，然后是基类成员变量，然后是子类成员变量。


文件管理：
*软链接和硬链接：
类似于强引用和弱引用，硬链接会增加引用计数，并且是一样innode值，只有引用计数变为0的时候才会真正删除文件，所以一个文件如果有硬链接，那么删除该文件时其实并不会真正删除，只是引用计数减一。
软链接实际上是新增了一个文件，该文件有自己的innode值，该文件存放所链接的文件的地址，并不增加原文件的引用计数，所以如果将原文件删除，软连接就无法访问了。有点类似于windows中的快捷方式。


用户态和内核态的区别：
操作系统的两种运行级别，用户态的特权级较低，内核态特权级较高，运行在用户态的程序不能直接访问操作系统内部的数据结构和程序。内核态和用户态之间的转换方式主要包括：系统调用，异常和中断。

系统调用：
用户程序需要执行一些需要较高权限的操作，具有一定危险性的操作，这些操作由操作系统封装好后暴露给用户程序，称为系统调用，例如open，write，fork，vfork等。
