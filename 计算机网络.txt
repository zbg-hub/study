TCP UDP：
*TCP的可靠性：
1.序列号，确认应答，超时重传
2.拥塞控制：慢启动，拥塞避免，快重传，快恢复
慢启动：一开始发送窗口为1，每过一个RTT，发送窗口大小加倍。
拥塞避免：窗口达到慢开始门限（初始值为16，发生超时变为当前拥塞窗口的一半）便开始拥塞避免算法，每过一个RTT窗口加一，若发生超时，拥塞窗口变为1。
3.快重传：接收方发现报文丢失发送连续3个确认报文，则发送方不再等超时重传，而是执行快重传。
4.快恢复：发送方收到3个确认报文表明可能不是发生拥塞而是报文丢失，于是执行快恢复，窗口变为原来的一半（门限值），然后执行拥塞避免算法。

*bic算法：
二分法思想来探测最佳窗口，在拥塞避免时，如果发生超时则将max_win设置成当前值，如果没有min_win，则将max_win乘法减小后设置为min_win，拥塞窗口cwnd取max和win的中点，如果没发生超时则将min_win设置为当前值，cwnd取中点，不断迭代求最佳窗口，在此过程中，为防止窗口抖动，设置一个Smax和Smin，如果窗口增量大于Smax的话，窗口只增大Smax，如果窗口增量小于Smin时，认为网络已基本稳定，可以将cwnd设置为max_win，此时需要进入max_probe阶段，一种说法为与前面对称，另一种说法为先将max_win设置为极大值，再开始一边慢启动，直到增量大于Smax，再进行二分。

cubic算法：
将整个bic算法优化为一个三次方程，消除了rtt不公平性。

*bbr算法：
传统的拥塞控制算法是通过丢包反馈来调整拥塞窗口的大小，但会带来一个问题：在高速链路中，丢包可能不仅仅因为拥塞，还有可能因为误码，所以在高速链路中使用传统的拥塞控制算法，可能会使得拥塞窗口收敛到一个比最大带宽小很多的值，造成带宽浪费。
算法细节：
bw：实时的传输速率，应答的数据量/应答的时间
rtt：一个包从发出到收到确认的时间
BDP：最大发送量为最大bw乘以最小rtt
inlight：发送但未确认的数据
四个阶段：
启动：类似于慢启动，以指数的速率增大发送窗口，希望能快速嗅探到带宽上限。
排空：启动之后，发送窗口会超过带宽上限，如果发现3个rtt内bw未增加，则进入排空阶段，排空实际为启动的逆过程，将多出的buffer慢慢排出，直到inflight<BDP。
带宽探测：探测最大带宽，增加buffer看bw是否增加。
时延探测：探测最低时延，减小buffer来探测最低时延。

拥塞控制算法评价标准：
链路利用率、RTT公平性和TCP友好性

TCP建立连接三次握手：
1.客户端发送连接请求。（SYN）
2.服务端收到请求并回复确认。（SYN）
3.客户端收到确认，此时客户端建立连接，客户端再发一条确认，服务端收到确认后连接建立。
为什么要进行三次握手而不是两次握手？
第一次握手报文丢失：防止失效SYN建立无效连接浪费服务端资源，例如一个客户端第一次发送SYN超时了，发送第二次SYN并建立了正确的连接，释放连接后，第一次失效的SYN到达，服务器认为是又一次建立连接，然后等待客户端发送请求数据。
第二次握手报文丢失：服务器端建立连接，客户端未建立连接，服务端重复发送数据，客户端因为未建立连接忽略数据报文造成死锁。

tcp fast open:
在第一次握手时，允许客户端携带数据，在第二次握手后，如果服务端验证了cookie，便不用等客户端的ACK而直接发送数据，此时服务端这边并没有建立连接（半连接状态），只是预先发送了一部分data，如果超时没有收到客户端的ACK，是不再继续等待，而是直接释放。

nagle算法：
防止出现过多非常小的数据包，例如有些数据包只有1字节的有效数据，但实际要发送41字节的数据包，为了传输效率，tcp默认使用nagle算法，当发送端缓存的数据达到一定值（MSS）或收到上一次的ack，才会将缓存中的数据发出去。

tcp粘包：
指多个应用层数据包粘连在一起的情况，导致应用层无法解析。
解决办法：禁用nagle
应用层定义协议，来进行消息定界。

TCP断开连接四次挥手：
1.客户端发送断开连接请求并进入等待状态（FIN_WAIT_1），此时仍然可以接受服务端数据。（FIN=1)
2.服务端接收到请求后发送一个确认报文，服务器进入CLOSE_WAIT。
3.客户端收到确认报文后进入第二次等待状态（FIN_WAIT_2），等待服务端将剩余数据传输完毕，然后服务端再一次发送确认报文。（FIN=1)
4.客户端收到确认报文后再次发送确认报文（TIME_WAIT）并等一段时间关闭连接，服务端再次收到确认报文后关闭连接。
为什么要进行四次挥手？
因为第二次挥手时，服务端数据可能没有传完，只能先回复一个ACK，待数据传完后才能回复一个FIN。
为什么要等2MSL
最后一次报文可能丢失，若丢失，服务端会一直发送FIN，若这时客户端关了则不会再发送最后的确认报文。
保证所有过期的报文都在网络中消失。

客户端发完FIN包后服务端不回包？
客户端重发FIN，重发数次后断开连接，最后发送一个RST包。

服务端出现大量close_wait状态？
线程阻塞没法发送fin包或者没有主动close。

服务端如果不调用accept会怎样？
因为三次握手不是accept函数的职责，所以客户端会收到最后一次syn而认为已经建立了tcp连接，但是服务端并不这么认为，从而导致拜占庭问题。
解决办法：客户端发包服务端收到后回复一个rst包

*linux如何查看哪些端口处于TIME_WAIT？
netstat命令用于显示与IP、TCP、UDP和ICMP协议相关的统计数据。

TCP和UDP区别：
1. TCP面向连接，UDP是无连接的
2. TCP点对点，UDP可以是一对一，一对多，多对一，多对多
3. 可靠性：TCP是可靠交付：无差错，不丢失，不重复，按序到达，UDP是尽最大努力交付，不可靠
4. TCP有拥塞控制和流量控制，UDP没有
5. 特点：TCP安全可靠，UDP便捷迅速

TCP保活机制：
keep-alive功能

*RST包的发送时机：
1、端口未打开
2、请求超时
3、提前关闭
4、在一个已关闭的socket上收到数据

HTTP返回码：
1xx：临时响应（需要请求者继续执行操作）
2xx：成功
3xx：重定向（表示要完成请求，需要进一步操作，定向到其他url）
4xx：请求错误
5xx：服务器错误

http请求转发和重定向的区别：
请求转发是服务端行为，重定向是客户端行为。
请求转发是服务端代替客户端完成请求，重定向是服务端提供新的url后，客户端再去做新的请求。

HTTP和HTTPS：
区别：
1.HTTP是明文传输，HTTPS经过TLS加密，具有更高的安全性。
2.HTTPS在TCP三次握手后，还需要进行SSL的handshake，协商加密使用的对称加密密钥（为什么不使用非对称加密？同样的加密强度对称加密更快，非对称加密主要用于签名以及密钥的加密）。
3.HTTPS协议需要服务端申请证书，浏览器端安装对应的根证书。
4.HTTP协议端口是80，HTTPS协议端口是443。

TLS/SSL握手：
1. 客户端向服务端发送版本信息，加密算法，随机数（用于生成对称密钥）等信息
2. 服务端收到后，给客户端发送版本号，加密算法，随机数，以及公钥等信息，公钥先要发给CA用CA的私钥进行签名认证变成公钥证书。
3. 客户端收到后使用内置的CA公钥进行验证，确保返回的公钥是受信任的服务器给的。
4. 客户端生成对称加密密钥，使用服务器发来的公钥进行加密，传输给服务端
5. 服务端收到密钥，并使用对称密钥加密传输。

*IP报文头中比较重要的字段：
版本（ipv4,ipv6）
标识：在ip分片以后，用来标识同一片分片的。方便ip分片的重组。
标志：该字段是与ip分片有关的。其中有三位，但只有两位是有效的，分别为MF，DF，MF。MF标识后面是否还有分片，为1时，表示后面还有分片。DF标识是否能分片，为0表示可以分片。
TTL：生存周期
源地址和目的地址：标识源IP和目的IP。

TCP报文头中比较重要的字段：
源端口和目的端口
序号seq
确认号ack
紧急URG:当 URG=1 时,表明紧急指针字段有效.它告诉系统此报文段中有紧急数据,应尽快传送(相当于高优先级的数据)
确认ACK:只有当 ACK=1 时确认号字段才有效.当 ACK=0 时,确认号无效
PSH(PuSH):接收 TCP 收到 PSH = 1 的报文段,就尽快地交付接收应用进程,而不再等到整个缓存都填满了后再向上交付
RST (ReSeT):当 RST=1 时,表明 TCP 连接中出现严重差错（如由于主机崩溃或其他原因）,必须释放连接,然后再重新建立运输连接
同步 SYN:同步 SYN = 1 表示这是一个连接请求或连接接受报文
终止 FIN:用来释放一个连接.FIN=1 表明此报文段的发送端的数据已发送完毕,并要求释放运输连接

http正向代理反向代理
正向代理：由客户端设置代理服务器地址，客户端在向服务器发出请求后，将请求发送给代理服务器，由代理服务器来完成请求，如在防火墙内的客户端要访问internet，或者要访问一些被屏蔽掉的国外网站。
反向代理：由服务端来设置代理服务器，用代理服务器来接收internet上的连接请求，然后将请求转发给内部网络上的服务器，并将得到的结果返回给客户端，对客户端表现为真实的服务器，例如分区域设置代理服务器，则在不同的地方ping同一个域名可能得到不同的ip，这些ip实际上是代理服务器的ip。
透明代理：设置在网关上，网站服务器和客户端都感知不到代理的存在，例如服务器看到的源ip是客户端的ip。

get和post
1. get通过url传递参数，post通过request传递参数
2. get在url中传递的参数有长度限制，post没有
3. GET请求会被浏览器主动cache，而POST不会，除非手动设置。
4. GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。
5. GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。
6. GET在浏览器回退时是无害的，而POST会再次提交请求。
7. get将header和data一并发出去，服务器返回200，post先将header发出去，服务器返回100后将data发出去，服务器返回200。
8. 例如需要获得一张图片时用get，需要提交数据或者修改数据时用post。
9. 并无本质区别，本质都是建立tcp连接，只是由于协议规定以及不同的浏览器造成行为不同。

*http1.0和http1.1的区别
1. http1.1中增加了支持长连接，即一个TCP连接上传输多个http请求和响应，减少了建立和关闭连接的消耗和延迟，支持流水线，即可以将多个没有上下文关系的请求同时发送而不会被阻塞，但其实没有真正解决阻塞问题，因为响应的顺序必须和请求的顺序一致，如果有一个响应花了很长时间还是会阻塞后面的响应，这就是队头阻塞。
2. http1.1支持host域，多个域名对应一个ip，一个主机有不同的服务，对客户端表现为不同的主机（虚拟主机）
3. 节约带宽，http1.1支持只发送请求头，待服务器返回100后再发送请求体。

*http1.1和http2.0的区别
1. 多路复用：一个tcp连接复用多个请求和响应，基于流和二进制帧，每一个二进制帧都会标识自己属于哪一个流，保证客户端最后收到有序不错乱的数据，从而实现真正的并行。
2. 报头压缩：http1.1中对报头没有进行压缩直接传输纯文本，随着web技术的发展，一个页面的请求越来越多，所以http2.0对报头进行了压缩。
3. 服务器推送：在客户端请求之前便进行推送，例如客户端请求了html，服务端会返回html并推送css等

*quic:
1. 基于udp。
2. 前向纠错，即在报文中增加冗余数据，丢包时通过冗余包进行恢复。
3. 拥塞控制由内核转移到用户。

http如何从无状态变为有状态？
通过cookie和session，cookie就是一些缓存，sessionID就是会话id，在第一次访问服务器时创建，保存在cookie中。

*RPC：远程过程调用，简称为RPC，是一个计算机通信协议，它允许运行于一台计算机的程序调用另一台计算机的子程序，而无需额外地为这个交互作用编程。

*mac地址和ip地址的必要性：
分离网络层和物理层，使得网络协议具有更好的容错性和扩展性。

arp协议：
arp请求：先查本机的arp缓存表，如果没有，则广播一个arp请求报文，通过二层交换机广播出去，如果有缓存，则直接给交换机发送一个单播包，交换机根据mac地址来进行转发。
arp响应：主机收到广播后，与自己的ip地址进行比对，如果匹配，则返回一个回复包（单播），告知自己的mac。

网关，二层交换机，三层交换机，路由器：
网关一般是三层交换机或者路由器（没什么太大的区别），网关负责一个网段，有arp表，二层交换机没有arp表，只是通过mac地址与接口的对应关系进行转发，无论网关还是pc，都要先把mac帧发送给二层交换机（广播单播）。

dns协议：
递归查询：先向本地域名服务器查询，如果查询不到，则本地域名服务器向根域名服务器查询，查询不到，则根域名服务器向顶级域名服务器查询，查询不到，则顶级域名服务器向权限域名服务器查询。
迭代查询：本地域名服务器->根域名服务器，本地域名服务器->顶级域名服务器，本地域名服务器->权限域名服务器。

dhcp原理：
如果主机配置了dhcp，则在接入网络后，会发送一个dhcp discover的广播包，这个广播包只有dhcp服务器（一般是网关）才会响应，然后dhcp服务器会回复一个包，包含给该主机分配的ip，本地dns服务器的ip，及该网段的默认网关的ip。

输入百度的url到看到百度的网页发生的过程：
1. dns解析，通过设置的local dns服务器的地址查询百度url对应的ip（递归，迭代）。
2. 发现目的主机不在该网段，直接发给默认网关。
3. 查询默认网关的mac，查不到的话（第一次）需要进行arp解析。
4. 默认网关根据路由表将报文发送给其他网关路由器。

localdns和httpdns：
localdns基于udp，dns请求容易被劫持，从而导致访问不到服务器或者访问到错误的服务器，htppdns基于http，而http又基于tcp，不容易被劫持，且主机绕开了本地域名服务器，直接与httpdns服务器进行交互，服务器可以更准确定位主机ip的位置，从而返回的结果更加精确。

OSPF路由协议（Dijkstra算法）（单源最短路径问题）
初始化：将所有节点分为两堆，S表示已确定最短路径的节点，U表示未确定最短路径的节点，U中的节点最短路径都设置为无穷，将源点加入S，最短路径为0，下一跳为空，并将源点设置为当前节点。
迭代：
1. 计算当前节点的所有相邻节点到源点的最短路径及下一跳（最短路径为与当前节点的距离+当前节点的最短路径；下一跳为当前节点的下一跳，如果当前节点的下一跳为空的话则为该相邻节点），并更新U中对应的节点的最短路径及下一跳。
2. 选取U中最短路径最短的节点放入S中，并将该节点设置为当前节点。
3. 重复12直到所有节点均进入S中。
时间复杂度为O(n2)

*弗洛伊德算法（多源最短路径问题）
首先假设两点之间不能经过中间点，则最短路径即为两点直连路径，然后假设可以通过1节点来中转，可以通过2节点来中转...更新邻接矩阵中的路径即可。
时间复杂度O(n3)

同步IO，异步IO，阻塞IO，非阻塞IO
阻塞和非阻塞指的是事情没发生要不要等它发生，同步和异步是事情发生过程中要不要等它发生完。

*如何将一个socketfd设置为非阻塞？
通过fcntl函数。