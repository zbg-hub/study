*1. 两数之和
利用hashmap，遍历数组，将数组存入map中，key为数值，value为索引，并在遍历过程中先检查map中是否存在与当前数值匹配的元素，如果有就返回（不存在重复的答案，故不存在([2,2,3,4],5)这样的case），不存在再插入。
**2. 两数相加
从低位到高位相加，注意最后多出来的进位。
*3. 无重复字符的最长字串
左右指针，建立一个unordered_set，外循环左指针向右移动时，指针指的元素出set，内层循环向右移动时，判断指针元素是否在set中已经存在，如果存在，返回不重复的长度，如果不存在，右指针元素进set。时间复杂度为O(N)，unordered_set的查找效率为O(1)，右指针每次从上次的位置向右移动就好（因为前面肯定是不重复的了）。
***4. 寻找两个正序数组的中位数（要求时间复杂度为O(log(m+n))）
二分法，寻找两个有序数组第k大的数，k为(m+n)/2或者(m+n)/2与(m+n)/2+1的均值
寻找两个数组AB下标为k/2-1的数（注意处理越界）比较大小，如果A较小，则A[k/2-1]不可能为第k小的数，排除掉前面所有的数，如果B较小同理，更新k值，直到有一方越界或者k=1。
*5. 最长回文子串
P[i][j]表示s[i]到s[j]是否为回文子串，1为是，0为否。
则P[i][j]=P[i+1][j-1]&&(s[i]==s[j])
然后遍历一遍找出j-i最大的P[i][j]。
//6. Z 字形变换
按行去寻找每行对应的索引，第一行和最后一行只有一种索引，中间行有两种索引，间隔都为固定值，为2(rows-1)，注意ros=1的情况为特殊情况。
//7. 整数反转
对10求模来从低到高取每一位，在溢出判断时，上一轮的res满足(res > INT_MAX/10 || (res == INT_MAX/10 && pop > INT_MAX % 10))则计算后的res溢出，负数同理。
**10. 正则表达式匹配
dp[i][j]代表s的前i个能否和p的前j个匹配（s为字符串，p为模式）
状态转移方程                 dp[i-1][j-1], match(s[i-1],p[j-1])
              if(p(j-1)!='*')={
dp[i][j]={                       false,otherwise
                                 dp[i-1][j]ordp[i][j-2], match(s[i-1],p[j-2])
              otherwise={
                                 dp[i][j-2], otherwise
解释：match(s[i],p[j])当s[i]==p[j]或p[j]=='.'为1
当p(j-1)='*'时，'*'代替的是p(j-2)所以需要看 match(s[i-1],p[j-2])来确定'*'能否将s[i-1]包含进去，如果可以包含进去，则有两种可能，一种是'*'不省略，则看dp[i-1][j]，如果s的前i-1个可以和p的前j个匹配，那即使再加个s[i-1]（第i个）也可以被*包含进去。第二种是*省略，则看dp[i][j-2]。
若match(s[i-1],p[j-2])不成立，则*必须省略，看dp[i][j-2]。
*11. 盛最多水的容器
双指针，一个指针在左，一个指针在右，每次移动高度较小的指针，计算面积，最后取最大值。原理是每次左右指针，以高度较小的指针为边界的面积中，宽度最大的面积最大，所以每次移动都是在计算以较小高度指针为边界的面积中的最大值，减小了复杂度。
14. 最长公共前缀
对于每个字符，从左到右将所有的str扫描一遍，若全都相同，则把字符推入最后的结果中，否则将结果返回。
也可将strs按照str的长度排序，则只用比较第一个和最后一个。
*15. 三数之和
排序加双指针：首先快速排序，然后外层循环i到len-2，内层循环双指针：left=i+1,right=len-1，if(nums[i]+nums[left]+nums[right]==0)则将三个数记录，如果大于0则右指针左移，小于0左指针右移，注意循环时，如果和上一次重复则跳过避免出现重复三元组。
*16. 最接近的三数之和
思路与上题类似也与11题思路相似，先排序然后固定一个指针i，然后j=i+1，k=nums.size()-1，cur=nums[i]+nums[j]+nums[k]，对于每一个cur都与ans做比较看是否更接近target，以此来更新ans，当cur>target时，则右指针左移，否则左指针右移，其实就是一个遍历的过程，但是在遍历的过程中排除了很多不可能的答案。
**17. 电话号码的字母组合
全排列问题，递归，例如求"2,3,4"所有可能的全排列只需递归调用函数求"3,4"的全排列再与2的全排列进行组合，注意递归的终点是只有一个数字，需要特殊处理输入为空的情况。
19. 删除链表的倒数第N个节点
用快慢指针来寻找倒数第n个节点，快指针先走n+1步（保证慢指针指向要删除的节点的前一个），如果快指针走的时候遇到已经为空了还要往前走，说明需要删除第一个节点，需要做特殊处理。
20. 有效的括号
栈的应用，遇左进栈，遇右与栈顶比较是否匹配，匹配则出栈，不匹配则返回false，结束后看栈是否空，空返回true，不空返回false。
21. 合并两个有序链表
链表的归并排序
*22. 括号生成
回溯法：回溯中要有状态量：当前的拼接str，左括号的数量，右括号的数量。如果str长度为2n则将str推入结果中，否则若左括号小于n推入一个左括号，改变状态后递归调用拼接方法继续拼接，然后pop掉左括号，若右括号小于左括号，则推入一个右括号，递归调用拼接方法继续拼接，再pop掉右括号。
*23. 合并K个排序链表
与合并两个有序链表相似，每次选最小的放入合并的链表中，在选取最小的节点时，可用小顶堆（优先级队列）来优化。
*25. K 个一组翻转链表
可以用栈来做，每个用一个栈来反转，然后递归调用。
**31. 下一个排列
下一个字典序：从右向左找到第一个升序nums[i]<nums[i+1]，则后面的排列不可能有更大的（降序），从i向右寻找最小（最后一个）的且比nums[i]大的nums[j]，交换i,j，并将i之后的子数组反转（变为升序）。
***32.最长有效括号
栈法：
-1先入栈，遇到'('，将序号入栈，遇到')'，将栈顶出栈，若此时栈空则将序号入栈，否则用当前序号-栈顶元素得出该有效子字符串的长度，并和最大长度相比较得到最大长度。核心思路是保证栈顶元素为非有效子字符串的最后一位的序号，或者说栈中都是没有被匹配过的正括号。
动规：
dp[i]表示以s[i]结尾的有效子字符串长度。
初始化都为0；
若s[i]==')'：
1. 若s[i-1]=='('，dp[i]=dp[i-2]+2;
2. 若s[i-1]==')'，若s[i-dp[i-1]-1]=='('，则dp[i]=(i - dp[i - 1] >= 2?dp[i - dp[i - 1] - 2]:0)+dp[i - 1] + 2。注意数组越界问题。
**33. 搜索旋转排序数组
用二分法，首先判断哪边有序，然后判断target在哪边，更新left,right和mid，注意一些特判。
***34. 在排序数组中查找元素的第一个和最后一个位置
使用两次二分法，第一次找左边界，第二次找右边界，注意不存在左右边界的情况，找右边界时注意不要进入死循环。
*39. 组合总和
回溯+剪枝：利用递归进行回溯例如candidates = [2,3,5], target = 8，可求candidates = [2,3,5], target = 6，candidates = [2,3,5], target = 5，candidates = [2,3,5], target = 3，再进行组合，剪枝可以先对candidates 排序，则遇到target <=candidates [i]可剪枝，另外避免重复进行剪枝，例如求candidates = [2,3,5], target = 5时（枝为8-5=3）便不必再求比3小的枝candidates = [2,3,5], target = 3（枝为5-3=2）。
深搜+回溯：先排序，然后深搜递归遍历，当sum=target时，将结果推入，遍历时，每个节点的孩子从自己开始向后，避免重复。
42. 接雨水
每一列的雨水高度为min(左面最高墙的高度，右面最高墙的高度）-当前列墙的高度，用两个数组将每一列的左面最高和右面最高墙的高度存下来（需要遍历一遍）。
*46. 全排列
递归，深搜，回溯
48. 旋转图像
先将矩阵转置，就是将matrix[i][j]和matrix[j][i]交换，然后将每一行反转。
49. 字母异位词分组
建立一个map，key是单词的字典序，value是string数组，遍历一遍，如果元素的字典序不在map中，则将该元素的字典序和只有该元素的数组加入到map中；如果存在，则将对应key的string数组添加一个该元素，最后将map的value保存到数组中返回。（用哈希map要快的多）
53. 最大子序和
dp[i]表示以i为终点的连续最大和（连续），则dp[i]=array[i](dp[i-1]<=0)或array[i]+dp[i-1](dp[i-1]>0),结果取dp[i]中最大值。
55. 跳跃游戏
如果不能到达某一点，那它后面的点一定无法到达，反过来如果能到达某一点，那它前面的点都能到达，所以遍历数组，维护能到达的最远的点，如果发现当前遍历的点已经超了最远可到达的点则最后一点无法到达。
**56. 合并区间
先将所有区间按照左边界排序，然后依次看当前区间与已生成的区间是否能合并，如果能合并则更新生成的区间，如果不能，则将生成的区间推入最后的结果，注意最后退出循环要将剩余的区间推入。
62.不同路径
dp[i][j]表示(0,0)到(i,j)的路径
状态转移方程：dp[i][j]=dp[i-1][j]+dp[i][j-1]
64. 最小路径和
dp[i][j]表示从(0,0)到(i,j)的最小路径和
状态转移方程：dp[i][j]=min(dp[i-1][j],dp[i][j-1])+grid[i][j]，注意dp数组初始化。
70. 爬楼梯
斐波那契数列。
*72. 编辑距离
dp[i][j]表示s1[0...i]转变为s2[0...j]所需要的最小的操作。（dp[i][j]表示s1前i个变为s2前j个所需要的最小操作的话初始化会比较方便，dp[0][0]=0,dp[0][j]=j,dp[i][0]=i）。
转移方程：如果s1[i]==s2[j]，那么dp[i][j]=dp[i-1][j-1]；
如果s1[i]!=s2[j]，则dp[i][j]=min(dp[i-1][j-1],dp[i][j-1],dp[i-1][j])+1
dp[i-1][j-1]到dp[i][j]需要进行替换操作
dp[i][j-1]到dp[i][j]需要进行插入操作
dp[i-1][j]到dp[i][j]需要进行删除操作
73. 矩阵置零
先统计那些位置有0，统计时，将对应的行和列记录下来，最后将这些行和列的元素都置0。
**75. 颜色分类
三个指针，left指向第一个不为0的元素，right指向第一个2前面的一个元素，index指向当前扫描的元素，如果当前扫描的元素是0，则与left交换并将left和index右移（因为左面都扫描过，交换过来的也扫描过，不用再扫描一遍），如果是2则与right交换并将right左移（右面的没有扫描过，所以交换过来要再扫描一遍，index不右移），如果为1则将index右移。当index>right时结束。
***76. 最小覆盖子串
双指针：两个指针left和right，如果发现当前的字串包含目标字符串，则left右移，如果不包含则right右移，在判断是否包含时可以使用hash_map，key为26个字母，value为出现的次数。
78. 子集
这种全排列子集问题一般通过回溯来解决，回溯函数中的状态量为结果数组res，当前数组cur，原始数组，遍历序号index，从遍历序号开始向后遍历，每遍历一个序号，把它推入cur，将cur推入res，当index越界后return（回溯）。注意加上空子集。
**79. 单词搜索
剑指原题，深搜+回溯，注意状态变量需要设置一个走过的点的标记flag，每进一次递归就要将flag更新，return false前也要进行更新，注意特判以及剪枝，不然容易超时。
***84. 柱状图中最大的矩形
思路：枚举每个高度，则这个高度对应的最大面积的左边界为左边第一个小于该高度的地方，右边界为右边第一个小于该高度的地方，难点为如何快速找到左右边界，如果分别向左右开始搜索，则时间复杂度较高，可以利用单调栈来辅助。
利用单调栈，以寻找左边界为例，具体操作是：栈初始化为-1（哨兵），循环一遍，如果栈里只有哨兵或当前循环的高度大于栈顶序号对应的高度，将栈顶序号推进左边界数组，然后将当前循环到的序号入栈；否则出栈直到达到第一个条件(i--)。寻找右边界类似，找到后，循环一遍，当前高度对应的面积就是高度*该高度对应的左右边界的距离，找出最大的面积即可。
***85. 最大矩形
使用上题的结果，可以将矩阵按行变为多个柱状图（每个一柱子为列），分别计算各个柱状图的最大面积，最后求出最大面积，而求柱状图最大面积的入参heights可以这样求：按照行循环，如果matrix[i][j]==0，则heights[j]=0,否则heights[j]++。
*94. 二叉树的中序遍历
二叉树的遍历（递归非递归）。
***96. 不同的二叉搜索树
可以利用递归去求解，例如numTrees(n)枚举不同的根节点i，左边小于i，右边大于i，则ans(i) = ans(i-1) + numTrees(i) * numTrees(n - i - 1)，递归求解会超时，可以利用记忆化来优化，将计算过的结果存储下来，后续计算便不用重复计算，序号不一定要从0开始，选择最容易理解的序号方式。
**98. 验证二叉搜索树
看中序遍历结果是否递增（用非递归写），注意最小INT_MIN的问题，可以加一个flag判断是不是遍历第一个点。
**101. 对称二叉树
剑指原题，判断左子树和右子树是否关于root镜像即可。
迭代写法：两个方向遍历该树，一个是根左右，一个是根右左，则如果二叉树对称的话两个方向遍历结果完全相同，如果发现不同则返回false，两个方向遍历的话可以用两个栈或者一个双端队列。
102. 二叉树的层序遍历
使用两个辅助队列及一个标志位来判断遍历哪一层。
也可以在while循环里加一个for循环，循环次数就是当前队列中的元素个数（每一层的节点数）。
104. 二叉树的最大深度
左子树的深度与右子树深度的较大值+1，递归终点是root==NULL。
***105. 从前序与中序遍历序列构造二叉树
前序遍历为12473568，中序遍历为47215368，则可知1为根结点，247为1的左子树，3568为1的右子树，递归即可得到完整二叉树。
***114. 二叉树展开为链表
前序遍历一遍，递归时要记录一下上一次浏览过的节点，并且在浏览右节点时需要提前把右节点存下，不然右节点的值会被改变。
也可以用右根左的遍历方式，在遍历根时，将根的左节点置空，右节点变为上次浏览的节点。
***115. 不同的子序列
dp[i][j]表示s(0..i)中t(0..j)出现的次数
状态转移：
dp[i][j] = (j > 0 ? dp[i - 1][j - 1] : 1) + dp[i - 1][j] （s[i]==t[j])（当j==0时，由于s[i]==t[j]，所以至少会出现1次）
dp[i][j] = dp[i - 1][j]  (s[i]!=t[j])
注意中间某些dp会出现超越int的情况。
121. 买卖股票的最佳时机
第一反应是单调栈，但是单调栈是为了找到所有位置两边第一个比它大或小的数，但是此题求的是所有位置两边（左边）最大或最小（最小）的数，所以没必要用单调栈，其实就像84. 柱状图中最大的矩形和42. 接雨水这两道题的关系。第i天卖出的最大收益就是第i天的价格减去前i-1天的最低价格，遍历一遍就可求出最大收益。
***124. 二叉树中的最大路径和
maxGain来计算每个节点的最大贡献值（以该点为起点往下搜索的最大路径和），节点的最大贡献值为该节点值+(子节点的最大贡献值的最大值,0)，而每个节点的最大路径和（该节点不一定为起点，可以是经过，但不考虑向上搜索的结果，向上搜索的结果在它的父节点中考虑过了）为该节点值+子节点中大于0的最大贡献值。也可以在返回最大贡献值的时候把小于0的结果变为0，因为小于0是没有意义的。
**128. 最长连续序列
要求时间复杂度为O(N)，使用哈希表，遍历哈希表，遍历到100时，如果发现没有99，便匹配101，102，103...，如果发现存在99，则说明100一定不是最长连续序列的起点，便不再匹配。虽有两层循环，但是每个数例如101只会匹配到一次，所以是O(N)的时间复杂度。
136. 只出现一次的数字
位运算，异或，任何数与0异或为其本身，任何数与其本身异或为0，所以对数组中的所有元素依次异或，最后的结果就是只出现一次的数。
***139. 单词拆分
dp[i]表示前i个字符是否合法。
状态转移：j（从0到i-1遍历）表示分割点，将前i个字符分割为两部分，若有某个j使得dp[j]&&check(j,i-1)为真则dp[i]为真。其中check(j,i-1)表示s(j...i-1)是否存在于wordDict中。
注意剪枝可提高效率，枚举j时倒着枚举，当发现s(j...i-1)已经超过wordDict中最长单词的长度便可停止枚举。
141. 环形链表
快慢指针，快走2，慢走1，若快慢可以相遇则存在环，否则不存在环。
142. 环形链表 II
判断出有环则令其中一个指针=head，各自每次走1，再次相遇便是入口。
*146. LRU缓存机制
哈希表+双向链表
哈希表存储key及key对应在双向链表中的节点，双向链表存储key和value，对于get操作需要把要查的元素在链表尾remove掉，再在表头add，然后再返回查询的值，对于put操作需要看是缓存是否已满，是增还是改，改的话需要将改后的元素放到表头。为了方便查找表头和表尾，可以设置伪表头和伪表尾。
为何要用哈希+双向链表：哈希保证查询修改操作为O(1)，双向链表保证时序性。
为何链表中需要存储key：缓存满后，再插入需要删除表尾元素，而哈希表中也要删除该元素，如果链表中不存key，则哈希表无法知道需要删哪个元素。
***148. 排序链表
链表归并，快慢指针找中点，先断开，再合并，设置一个伪头节点用来归并，数组的归并需要开辟额外数组。递归的空间复杂度为O(logn)。
非递归：从length=1开始向上迭代，在相同的length的不同轮次中，需要将需要合并的两条链表断链（变成两条独立的链表），需要设置上一次排序好的尾节点及这一次排序好的头节点进行挂链，在第一轮次中需要更新头节点。
152. 乘积最大子数组
dp[i]表示以i结尾的子数组的乘积的最大值
状态转移：dp[i]=max(dp[i-1]xnums[i],nums[i])，遍历一遍求最大值。
错！
(5,6,-3,4,-3)，dp[i]为(5,30,-3,4,-3)求得最大值为30，实际最大值为数组全部元素的乘积，因为当nums[i]为负时，要求最大值，希望以i-1结尾的子数组中有一个最小的负数来抵消，所以该算法有问题。正确做法：维护两个数组
maxdp[i]表示以i结尾的子数组的乘积的最大值，mindp[i]表示以i结尾的子数组的乘积的最小值
状态转移：maxdp[i]=max(maxdp[i-1]xnums[i],mindp[i-1]xnums[i],nums[i])
mindp[i]=min(maxdp[i-1]xnums[i],mindp[i-1]xnums[i],nums[i])
遍历一遍求最大的maxdp[i]。
155. 最小栈
剑指原题，辅助栈
160. 相交链表
剑指原题，从结尾寻找第一个不相同的节点，可以用一个辅助栈。
169. 多数元素
使用抵消的思想，能留下来的一定是众数，如果众数的出现次数可能小于一半，则可以再遍历一遍统计一下众数的个数。
设置一个value，一个count，value初始为nums[0]，count初始为0，遍历数组，如果发现nums[i]=value，则count++，否则若count=0，则value=nums[i],count=1，若count!=0，则count--，最后的value就是众数。
198. 打家劫舍
dp[i]表示从0到i房间能打劫到的最大值
对于第i个房间，有两种选择，打劫i，不打劫i，若打劫i，则打劫到的最大金额为dp[i-2]+nums[i]，若不打劫i，则最大金额为dp[i-1]，所以状态转移为：dp[i]=max(dp[i-2]+nums[i],dp[i-1])。
199. 二叉树的右视图
层序遍历时，取最右面的即可。
200. 岛屿数量
对每个点进行遍历，遇到1则以该点为起点进行深搜，深搜内部，搜到1便把1变为0，搜到0不再往下搜，最后看一共进行过多少次深搜。
206. 反转链表
方法很多，剑指原题。
***207. 课程表
深搜，深搜时，每个点有三种状态，未搜索，搜索中，已完成（且无环），用一个数组来记录，对每个未搜索的点进行深搜，搜索到未搜索的点递归搜索，搜索到搜索中的点返回false，完成后将该点设置为已完成。
*208. 实现 Trie (前缀树)
前缀树成员变量：
bool isEnd;表示该节点是否是一个结束节点（结束节点下面可能还会有节点）
vector<Trie*> next;表示其孩子节点的数组，一般为26个，next[0]不为空代表该节点下有'a'节点。
搜索操作：按照要搜索的词，一个字符一个字符进行匹配，匹配结束后还要看最后匹配的字符是否为结束字符。
插入操作：与搜索操作类似，一个一个进行匹配，若发现匹配不到，就新建一个该字符的节点，一直到结束。
查找前缀操作：与搜索类似，只不过在最后不用检查最后一个字符是否为结束字符。
215. 数组中的第K个最大元素
剑指中有类似的题，可以建一个大顶堆（最好自己实现一下），然后做k-1次删除操作，最后堆顶即我们要的答案，时间复杂度：建堆的时间复杂度为O(N)，每次删除操作的时间复杂度为logN，所以总的时间复杂度为O(N+klogN)。
221. 最大正方形
动态规划
dp[i][j]表示以matrix[i][j]为右下角的最大正方形的边长
dp[i-1][j-1]表示对角线能延伸的范围，dp[i][j-1]表示宽能延伸的范围，dp[i-1][j]表示高能延伸的范围，则以matrix[i][j]为右下角能延伸的范围为三者的最小值，如果matrix[i][j]=0，则dp[i][j]=0。
状态转移：if(matrix[i][j]=1)：dp[i][j]=min(dp[i-1][j-1],dp[i][j-1],dp[i-1][j])+1
else：dp[i][j]=0。
226. 翻转二叉树
剑指原题，递归翻转。
234. 回文链表
要求O(N)时间复杂度，O(1)空间复杂度，先找到中点，将后半部分反转（也要用O(1)的方法），再判断前后是否相同。
236. 二叉树的最近公共祖先
递归：设fx表示x节点是否包含p或者q，fxl表示x的左节点是否包含p或者q，fxr表示x的右节点是否包含p或者q，则递归函数中，递归调用求出fxl和fxr，则x是最近公共祖先（ans=x）的条件是x左右节点均包含p或者q，或者x本身是p或者q，左右子节点其中一个包含p或者q，即(fxl && fxr) || ((x=p || x=q) && (fxl || fxr))。而返回值fx=fxl || fxr || x=p || x=q。注意剪枝，当左节点fxl求出后发现已经求出了ans，就没必要再求右面了，可以直接返回false。
238. 除自身以外数组的乘积
构建两个数组left和right，left[i]表示下标为i左面元素的乘积，right[i]表示下标为i右面元素的乘积，建立好之后，B[i]=left[i]*right[i]，时间复杂度为O(n)。
239. 滑动窗口最大值
维护一个单调队列，可以使用双端队列q，存的是nums的下标，每次滑动窗口，pop时候看要pop的下标和q.front()是否相同，push的时候保证单调，每滑动一次，队列头就是当前窗口的最大值。
为何要维护一个单调队列：例如队列为[2,3,5]，当前需要push的为4，则2，3是在4的前面进的队列，也就是说在nums中2，3在4的前面，那么当4进来的时候，2和3绝对不会再成为当前窗口的最大值了，所以需要pop掉。时间复杂度：因为每个元素最多被压入弹出队列一次，所以时间复杂度是O(N)。
240. 搜索二维矩阵 II
剑指原题，从右上角开始向下和向左搜索。
279. 完全平方数
数学方法：若该数是完全平方数，返回1，若该数=4的k次方x(8m+7)，则返回4。检查是否可至少分解为两个可通过枚举，若都不是则返回3。
动态规划：
dp[i]表示i可以分解成的最小完全平方和的个数
状态转移：dp[i]=min(dp[i-k])+1，k为小于i的完全平方数。最后dp[n]即为答案，时间复杂度为nx根号n。
**283. 移动零
双指针：慢指针代表了排好的非0元素的下一个位置，快指针代表遍历指针，快指针遇到非0则将该数换到i的位置上，然后往前走，遇到0直接往前走。
287. 寻找重复数
如果可以更改原数组，则可以遍历一遍数组，每次取当前值的绝对值，看以该值为下标的数是否为负，如果为负的话，直接返回当前遍历的值，否则的话将该值为下标的数变成负的并继续遍历。
第二种方法：把nums看成一个由i指向nums[i]的一个链表，nums[i]!=0，所以i=0时一定是头节点，如果nums[i]中有重复的数则意味着链表存在环，直接判断环的入口就可以了（想出这种方法的人脑子多少跟正常人有点不太一样）。
***297. 二叉树的序列化与反序列化
序列化时注意空节点，反序列化时，输入参数是字符串data和要反序列化的位置i，先将该数赋给根节点，再反序列化左子树，右子树，注意要传引用。
300.最长上升子序列
dp[i]表示以nums[i]结尾的最长上升子序列长度（包含nums[i]），则dp[i]=max(dp[j])+1,0<=j<i，且nums[j]<nums[i]。
***301. 删除无效的括号
暴力+剪枝：
每个括号都有两种选择，删除或不删除（例如括号有3个则可能性有8种，转化为二进制数来表示哪一位删除哪一位保留），把所有的可能性遍历一遍（从需要删除最少元素开始）求得结果。
BFS+预处理：
第一层为原始s，第二层为删除一个括号的所有可能（用set保存），第三层为删除两个括号的所有可能...遍历一遍，检查每层的所有可能中有无答案，有的话便可提前结束遍历。
预处理：可以将字符串前面的')'和后面的'('先全部删掉。
*309. 最佳买卖股票时机含冷冻期
dp[i][0]表示该天持有一支股票的累计最大利润
dp[i][1]表示该天不持有股票且是i天卖的
dp[i][2]表示该天不持有股票且不是i天卖的。
状态转移：dp[i][0]=max(dp[i-1],dp[i-1][2]-prices[i])
dp[i][1]=dp[i-1][0]+prices[i]
dp[i][2]=max(dp[i-1][1],dp[i-1][2])
***312. 戳气球
dp[i][j]表示开区间(i,j)中填满元素可获得的最大收益（不能是闭区间，因为填i和j的时候也有收益，而填i，j的收益又无法确定）
状态转移：dp[i][j]=max(nums[i]xnums[mid]xnums[j]+dp[i][mid]+dp[mid][j])，if(j-i>1) （mid为第一次填的位置）
dp[i][j]=0，if(j-i<=1)
注意填dp的顺序，以及j-i<=1的地方就不用填了。
///322. 零钱兑换
BFS：超时
动态规划：dp[i]表示amount=i时所需要的最小的硬币个数。
状态转移：dp[i]=min(dp[i-c]+1)(c in range coins)
注意初始化，以及在计算dp[i]时，若dp[i-c]<0为无效的，若发现这一轮所有的dp[i-c]都是无效的则dp[i]=-1。
*329. 矩阵中的最长递增路径
对每一个点进行深搜，但在深搜时，将每个点为起点的最长递增路径用一个矩阵记录下来，避免重复计算，最后求最大值。
**337. 打家劫舍 III
动态规划+后序遍历
f[i]表示选择i节点，i节点及子树所能获得的最大收益。
g[i]表示不选择i节点，i节点及子树所能获得的最大收益。
状态转移：
f[i]=g[i->left]+g[i->right]+i->val
g[i]=max(f[i->left],g[i->left])+max(f[i->right],g[i->right])
后序遍历一遍求max(f[root],g[root])。
338. 比特位计数
此题是要求1-num所有的数的bit位数
101的1的位数位10的位数加101&1，所以ans[i]=ans[i>>1]+(i&1)。
**347. 前 K 个高频元素
遍历一遍建个map，key是nums中的值，value是出现的次数，再建立一个k个元素的小顶堆，遍历一遍map，大于堆顶则将堆顶pop，然后新元素入堆，最后堆中的五个键即为所求。
*387. 字符串中的第一个唯一字符
建立一个map用于存每个字母出现的频次，建立一个queue来表明每种字母出现的顺序（可以存第一次出现时的序号），遍历queue查询第一个出现次数为1的字母，返回序号。
392. 判断子序列
双指针：两个指针i和j，i指向s中需要匹配的字符，j指向t中可能与s匹配的字符，如果s[i]==s[j]则两个指针右移，否则仅仅将j右移，当i移到了末尾说明可以匹配，如果j移到了末尾且i没有移到末尾说明无法匹配。
394. 字符串解码
可以用递归求解：
*如果要解析的位置超过s长度，则返回。
*如果要解析的不是数字而是字母（数量为1），将字符串解析完后加上后面的解析结果返回。如果后面有]则返回交给上一层解析（注意此时结尾可能没有]就结束了这种情况。
*如果要解析的为数字，求出数量，解析[]内的内容，括号内又遇到数字则递归解析，解析完后发现还有多余的反括号，则返回交给上一层解析，否则加上后面的解析结果返回。
399. 除法求值
用并查集做：
*建立两个map，一个用于存放边（节点->父节点），另一个存放权重（节点值/父节点值），建立一个set存放所有节点（判断一个节点到底是root还是不存在）
*寻找根节点：首先需要判断是否存在于set，然后根据存放边的map找到根节点。
*寻找到根节点的权重：根据两个map寻找根节点并将权重累乘。
*并：将一个由子节点指向父节点的边并入，首先看该子节点是否已经存在父节点，如果不存在，则直接添加，如果存在，则找到根节点添加到根节点后，注意先添加权重值再添加父节点，否则找到的根节点会有问题。并把父子节点放入set中。
*求值：先通过并操作初始化map和set，然后所求的值即为子节点到根节点的权重与父节点到根节点的权重的比值，要先判断两个的根节点是否相同，且其中有一个比值为-1则结果为-1。
406. 根据身高重建队列
根据身高降序，根据序号升序排列，然后遍历数组，把每个元素插入到它的序号代表的位置。
416. 分割等和子集
递归方法：
*先判断总和是否为偶数，如果是奇数返回false。
*降序排序，判断最大值是否大于一半，如果大于返回false。
*判断数组中是否有和target为数组总和一半的组合，递归中，如果发现nums[i]=target则返回true；如果nums[i]>target则从下一个索引开始搜索；如果nums[i]<target则返回两个结果的或，一个是从下个索引搜索target，另一个是从下一个索引搜索target-nums[i]。
动规方法：
01背包问题，求nums中是否有子集和为sum/2
dp[i][j]表示到下标i，是否有和为j的子集。
dp[i][j] = (j < nums[i] ? 0 : dp[i - 1][j - nums[i]]) || dp[i - 1][j]。
437. 路径总和 III
dfs:
在遍历过程中维护一个sumlist，每遍历一个节点，将sumlist的每个元素加上该节点的节点值，再将节点值本身推进去，sumlist代表了遍历到该节点时所有可能的路径和，则所求的结果就是目标值在sumlist中出现的次数。
438. 找到字符串中所有字母异位词
滑动窗口，注意判断字符串是否为异位词时，可以建立两个hashmap，来存储每个字母和它出现的次数，当窗口滑动时，不断更新map1并检查是否为异位词。
448. 找到所有数组中消失的数字
可以建立一个map来记录每个数是否出现过，最后将没有出现过的数输出。
可以在原数组上修改，类似于287寻找重复数，浏览过的数，将以它为下标的数变为负数，最后浏览一遍正数的序号即为所求。
461. 汉明距离
异或后统计1的个数。
494. 目标和
此题实际上是求对于一个数组，能不能分解为两堆使得sumA-sumB=S，这道题可以转化为01背包问题，两边同时加上数组所有元素的和sum则变为2sumA=S+sum，即sumA=(S+sum)/2，变成能找到多少个子集，使得子集和为(S+sum)/2。
dp[i][j]表示到下标i，有多少种子集和为j。
dp[i][j] = (j < nums[i] ? 0 : dp[i - 1][j - nums[i]]) + dp[i - 1][j]  //下标为i的元素是否取
dp[0][0]=1，注意若nums[0]=0(空集），则dp[0]=2（空集和取0）。
注意特判。
538. 把二叉搜索树转换为累加树
使用中序遍历的反遍历（右根左）把前面浏览过的节点的和加到该节点上。
542. 01 矩阵
bfs:
以所有的0为起点进行广搜，将所有的0先入队列，level为1，然后对所有的0进行广搜（所有的0都level1），遇到1则将该点的结果值设为level。注意搜过的点要标记一下避免重复搜索。
543. 二叉树的直径
对于每个节点来说，经过它的最大路径为左子树的深度+右子树的深度，则可以通过递归来求树的深度，在求树的深度的同时就可直接更新最大路径的值。
560. 和为K的子数组
暴力法：枚举左右边界的下标，外层枚举左边界，内层枚举右边界，在内层循环时，可直接用上次计算的结果+nums[j]即可。
前缀和+哈希表：
设[0...i]的和为pre[i]（前缀和）
子数组[j...i]的和为k，即pre[i]-pre[j-1]=k，即pre[i]-k=pre[j-1]，即对于每个i，看有多少个j-1使得等式满足。
建立一个map，key为前缀和pre，value为该前缀和出现的次数，将nums遍历一遍，对于每个i，看pre[i]-k在map种出现的次数，然后更新count，更新map（注意顺序，要满足j-1<i这个条件），注意还要将map[0]的初始值设置为1。
581. 最短无序连续子数组
排序法：将原数组排序，然后比较改动的左边界和右边界。
单调栈：求左边界时，维护一个单调递增栈，如果遇到递减，则不断pop直到递增，此时记左边界的序号为lefttemp，之后遍历，所求的左边界left=min(left,lefttemp)，右边界同理。
终极题解：从左到右循环，记录最大值为 max，若 nums[i] < max, 则表明位置 i 需要调整, 循环结束，记录需要调整的最大位置 i 为 high; 同理，从右到左循环，记录最小值为 min, 若 nums[i] > min, 则表明位置 i 需要调整，循环结束，记录需要调整的最小位置 i 为 low。一次遍历也可完成。
617. 合并二叉树
递归求解
如果都为空则返回空，如果一个不为空则返回另一个，如果均不空则返回两个节点相加的结果，节点的左右节点调用递归。
621. 任务调度器
先按照频次进行排序，应当优先安排频次高的任务，一个任务可以带n个不同的任务，可以建立一个大顶堆，开始时将所有的任务次数推进去，然后每次取n+1个，如果不够的话需要带空任务，取完后频次减一，如果频次不为0，再放回大顶堆直到大顶堆为空，每取一次时间就加一，注意最后一个任务不用再带空任务了。
647. 回文子串
与第5题相似
dp[i][j]表示s[i]到s[j]是否为回文子串，1为是，0为否。
状态转移：dp[i][j]=dp[i+1][j-1]&&(s[i]==s[j])
初始化时，i从后往前，j从i往后。
739. 每日温度
单调栈的简单应用，这道题是求每个元素右面第一个大于它的元素的位置，从右往左遍历，维护一个单调递减的栈，栈顶元素就是当前遍历元素右面第一个大于它的元素。