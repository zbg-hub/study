C++中一些关键字：
Static：
1.静态局部变量，定义在函数内，存储在全局数据区（静态区），随着第一次函数调用而初始化，不随着函数结束而销毁。主要作用为当函数调用结束后，变量值不变，再一次调用该函数时，该变量的值仍是上一次的值。和全局变量的区别：全局变量在程序一开始便初始化，静态局部变量在函数第一次调用时才初始化，且该变量是属于该函数的，易于维护。静态局部变量作用域为局部。
2.静态全局变量，定义在函数外，主要作用是隔离文件，即该变量对其他文件不可见。
3.静态函数，作用与静态全局变量类似，使得该函数对其他文件不可见。
4.静态数据成员，在class内定义，是类的变量，对象共享该数据
5.静态成员函数，是类的函数，非静态成员函数可调用静态成员函数，反之不可。

Cast强制转换：
1.static_cast,与C语言中的强制转换功能相近，用法：static_cast < type-id > ( expression )，没有安全性检查。
2.const_cast，转换掉表达式的const性质，用法：const_cast<type_id> (expression)，其中type_id与expression一致
3.dynamic_cast，基类和派生类指针引用类型的转换，有安全性检查，如果不安全会传回一个空指针
4.reinterpret_cast，较少使用。

隐式类型转换：
内置类型：从低精度到高精度编译器可自动完成类型转换，从高精度到低精度编译器会报警告。
自定义类型：本质是寻找合适的单参构造函数来完成隐式类型转换，要想禁止此种隐式类型转换，可以使用C++关键字explicit。

const：
1.const修饰普通类型的变量：被修饰的变量值不可改变，不可重新赋值。
2.const 修饰指针变量：
1).修饰内容 const int *p=8;内容不可改变（*p）。
2).修饰指针int* const p = &a;指针值不可改变（p）。
3).双重修饰：const int * const  p = &a;指针和内容均不可改变。
根据const的位置：左定值，右定向，const修饰不变量。
3.常引用：无法通过函数改变引用的内容。当我们希望传参时，不要再进行拷贝动作以提高效率又不想改变参数的内容，这时就要用到常引用。
4.const参数传递和函数返回值（const在最前面），修饰返回值时，则返回的值（指针）应该赋给同样类型的const指针。
5.常量成员函数（const在最后面）：无法改变成员变量的值，注意和静态成员函数区分。

volatile：
与const对应，告诉编译器该值可能会发生意想不到的变化，所以每次取值时都要去原地址去取，避免因编译器优化而导致的错误。

**const和define的区别：
（1）就起作用的阶段而言： #define是在编译的预处理阶段起作用，而const是在编译、运行的时候起作用。
（2）就起作用的方式而言： #define只是简单的字符串替换，没有类型检查。而const有对应的数据类型，是要进行判断的，可以避免一些低级的错误。 
（3）就存储方式而言：#define只是进行展开，有多少地方使用，就替换多少次,占用代码段空间；const定义的只读变量，占用数据段空间。
（4）从代码调试的方便程度而言： const常量可以进行调试的，define是不能进行调试的，因为在预编译阶段就已经替换掉了。

**inline和define的区别：
都是宏替换，inline只是向编译器的建议，不一定会成为内联函数，define只是简单的字符替换，没有类型检查和安全检查，但是内联函数有类型检查和安全检查。

extern C：
C++和C的编译方式，连接方式不同，C++支持重载，C不支持重载，所以在C++中，函数一般被编译为函数名+形参名的符号，在C中会被编译成函数名的符号，如果在C++中调用C语言编写的库，不加extern C的话，两者编译产生的符号不同，就会在链接产生问题。所以需要在C++调用C时加上extern C关键字。
用法：
1. 可以是单一语句：
extern "C" double sqrt(double);
2. 可以是复合语句：
extern "C"
{
      double sqrt(double);
      int min(int, int);
}
3. 可以是头文件，相当于头文件中的声明都加了extern C（最常用）
extern "C"
{
    ＃include <cmath>
}　

sizeof():
其作用是返回一个对象或类型所占的内存字节数。
指针的sizeof一般是4，x64为8。


*C++内存分配：
栈区（stack）：由编译器自动分配与释放，存放为运行时函数分配的局部变量、函数参数、返回数据、返回地址等。其操作类似于数据结构中的栈。
堆区（heap）：一般由程序员自动分配，如果程序员没有释放，程序结束时可能由OS回收。其分配类似于链表。
全局区（静态区static）：存放全局变量、静态数据、常量。程序结束后由系统释放。全局区分为已初始化全局区（data）和未初始化全局区（bss）。
常量区（文字常量区）：存放常量字符串，程序结束后有系统释放。
代码区：存放函数体（类成员函数和全局区）的二进制代码。
//main.cpp  
int a = 0; 全局初始化区  
char *p1; 全局未初始化区  
main()  
{  
int b; 栈  
char s[] = "abc"; 栈  
char *p2; 栈  
const char *p3 = "123456"; 123456\0在常量区，p3在栈上。
const char *p4 = "123456";则p3==p4，都指向常量区。
static int c =0； 全局（静态）初始化区  
p1 = (char *)malloc(10);  
p2 = (char *)malloc(20);  
分配得来得10和20字节的区域就在堆区。  
strcpy(p1, "123456"); 123456\0放在常量区，编译器可能会将它与p3所指向的"123456"
优化成一个地方。  
}  

函数调用机制：
函数调用本质是压栈出栈操作：
1. 参数从右到左压栈。
2. 调用函数返回地址压栈。
3. 函数返回值保存在eax寄存器中。

linux中检查内存泄漏的工具：valgrind，如何在代码层面来检查内存泄漏：可以在对new和delete或者对构造函数析构函数做统计来检测是否有内存泄漏。

*new和malloc的区别：
new是C++中的关键字，malloc是C语言中的库函数。
new和delete会自动执行对象的构造和析构函数，malloc/free不会
new申请对象所需的内存空间或整数倍（无需自己指定），malloc可以任意指定（需要显式地指定）要申请的内存大小。
new在自由存储区申请空间，malloc在堆区申请空间，自由存储区是一个抽象的概念，大部分时间，new就是在堆中申请内存，但是也可以通过重载new在其他内存空间上申请内存，所以自由存储区和堆并不完全等价。
new的返回类型即为申请的对象的指针类型，malloc返回void*

*malloc原理：
C++中的内存分配指的是虚拟内存的分配，每个进程都有自己的虚拟空间，而对于物理内存的分配，则是操作系统内核进行分配。
当进程申请的内存小于128k时，先搜索end_data之下有无合适的内存片（首次适配，下一次适配，最佳适配），如果没有，会使用brk系统调用在堆区分配内存，实际就是将_edata向高地址推进，如果申请的内存大于128k，则会调用mmap系统调用在文件映射区分配（动态库，共享内存，mmap分配的空间）
brk和sbrk都是移动end_data的位置，brk是移到哪而sbrk是移多少。

mmap文件映射：将文件映射到内存中代替频繁io，共享内存实际也是mmap在文件映射区开辟空间。

什么叫面向对象？什么叫继承，封装，多态？

面向对象（类，继承，派生）：
多态：指相同对象接受不同消息或不同对象接受相同消息而产生不同的动作（继承体系下同名成员函数的关系）。
静态多态和动态多态：
静态多态：一个类内的函数重载，根据不同的参数选择不同的函数实现。
动态多态：一个父类多个子类的虚函数重写，根据指向对象的类型进行选择不同的函数实现，基类指针指向子类对象调用子类方法。

重载，重写，重定义：（共同点是函数名相同）
重载：一个类内（一个作用域），参数不同，返回值可以不同。
重写（覆盖）：不同作用域（父类子类），参数相同，返回值相同，有virtual关键字。
重定义（隐藏）：不同作用域，只要不是重写，就是重定义。
重写根据对象类型调用方法，重定义根据指针类型调用方法。重定义不体现多态。

override关键字：
确保子类中声明的函数为父类中有的虚函数并重写，如果有override关键字的函数没有在父类中找到对应的虚函数编译器会报错。

构造方法能不能重载和重写？
构造方法可以重载但不能重写，因为重写是父类和子类相同的函数名，构造函数与类名相同，不能重写。

类的析构函数为什么必须是虚函数，为什么C++默认的析构函数不是虚函数：
当一个类作为父类时，如果析构函数不是虚函数，则用一个父类指针指向子类对象在销毁时只调用父类析构函数，不调用子类析构函数造成内存泄漏。但是如果一个类不作为父类时就没必要将析构函数设置为虚函数浪费资源，所以默认的析构函数不是虚函数。

何时必须写析构函数：
一般情况下，在销毁对象时，编译器会自动调用析构函数，但是如果类中出现了new需要手动写析构函数delete，以防内存泄漏。

*析构顺序：子类本身的析构函数；对象成员的析构函数；基类析构函数。

虚函数表的实现：
每一个类都有自己的虚表（该类有虚函数），表中有自己的虚函数的指针，每一个对象都有一个虚表指针用来指向自己的虚表。

继承方式：
公有继承：属性不变，但是私有成员不再有成员访问权限。
私有继承：属性均变为私有，原先的私有不再有成员访问权限。
保护继承：属性均变为保护，原先的私有不再有成员访问权限。

class和struct的区别：
struct默认继承为公有继承，class默认继承为私有继承。

RTTI(Run Time Type Identification)即通过运行时类型识别，程序能够使用基类的指针或引用来检查这些指针或引用所指的对象的实际派生类型：
通过RTTI机制来动态获得对象类型，使得可以将一个指向父类对象的指针转化为子类对象指针。
RTTI提供了两个非常有用的操作符：typeid和dynamic_cast。
typeid操作符，返回指针和引用所指的实际类型；
dynamic_cast操作符，将基类类型的指针或引用安全地转换为其派生类类型的指针或引用。

RAII全称是“Resource Acquisition is Initialization”，直译过来是“资源获取即初始化”，也就是说在构造函数中申请分配资源，在析构函数中释放资源。因为C++的语言机制保证了，当一个对象创建的时候，自动调用构造函数，当对象超出作用域的时候会自动调用析构函数。所以，在RAII的指导下，我们应该使用类来管理资源，将资源和对象的生命周期绑定。



引用：
引用即为变量别名，主要用途是传参，在C中传参的方式是传值不传址。

**指针和引用的区别？
1. 指针是一个地址，引用只是一个别名。
2. 引用不能为空，创建时就要初始化，指针可以为空，可以在任何时候初始化。
3. 可以有const指针不能有const引用（传参的时候可以有常引用，为了避免内存拷贝且避免改变原始数据）。
4. 指针可以有多级，引用只能有一级。
5. 指针在初始化后可以改变指向的内存地址，引用初始化后不能改变指向的内存地址。
6. 自增运算符的意义不一样。
7. 使用sizeof，引用返回的是对象的大小，指针返回的是指针的大小。

**左值和右值的区别：
1. 左值是可以取地址的表达式或具名对象，一般指表达式结束后依然长期存在的持久对象。
2. 右值指不能取地址的表达式或匿名对象，表达式结束后就会销毁消失的临时对象

**左值引用和右值引用：
普通的引用为左值引用，对于普通的引用，我们只能将引用绑定到左值上，而右值引用是将引用绑定到右值上。
右值引用的作用：1. 移动语义 2. 完美转发

**右值分类：
1. 纯右值：按值返回的临时对象、运算表达式产生的临时变量对象、原始字面量和lambda表达式等。
2. 将亡值：与右值引用有关。

智能指针：
主要解决内存泄漏问题，如在delete之前发生异常，或者在delete之前发生跳转，则delete无法执行而导致内存泄漏，智能指针将一个指针封装成一个类，在超过类的作用域时，自动销毁而不会留下悬空指针。
auto_ptr(C++98的方案，C++11已经抛弃)
采用所有权模式，赋值时编译器不会报错，但存在潜在的内存崩溃。
unique_ptr
不能赋值和复制，实现独占式或严格拥有概念
share_ptr
共享式拥有概念，多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放，使用计数机制表明资源被几个指针共享。
weak_ptr
weak_ptr设计的目的是为配合shrae_ptr而引入的一种智能指针来协助share_ptr工作，它的构造和析构不会引起引用计数的增加或减少。weak_ptr是用来解决share_ptr相互引用时的死锁问题，它是对对象的一种弱引用。

野指针：
在delete后，编译器只是释放掉了指针所指向的内存，但是并未清零指针，此时这种指针成为野指针，是不安全的。

如何避免野指针？
1. 初始化为NULL指针
2. 释放后清零


*容器算法STL：
stl六大组件：
容器，算法，迭代器，分配器，配接器，仿函数
容器：封装好的数据结构，如vector，list，deque，set，map等
算法：一种函数模板，如sort、search、copy、erase等
迭代器：泛型指针
分配器：负责空间配置与管理
配接器（适配器）：如stack，queue，看似容器，实际底层是由deque提供接口。其实是一种设计模式，将已有的接口转为需要的接口，例如反向迭代器就是迭代器的适配器。
仿函数：功能类似于函数的类，实际上是一个类中重载了operator()，使得一个类像一个函数。

stl分配器：两级配置器，如果需要的空间大于128B，会使用一级空间配置器malloc,realloc,free在堆中申请空间进行空间配置，小于128B时，会使用二级空间配置器（内存池，自由链表技术）。
内存池，自由链表：
有点类似于解决哈希冲突的链地址法，思想就是申请一大片内存作为内存池，分给8B,16B,24B...128B的16个内存链表（所有相同大小的内存块串成一个链表），链表头包含了可用的起始地址，可用空间等信息，空闲链表不够就去内存池中申请内存块，默认一次申请20块，如果内存池也不够了需要向堆中申请内存更新内存池大小，如果堆内存也不够了那就gg。

迭代器：把不同的容器的访问逻辑抽象出来，使得不用暴露集合内部结构而可以遍历集合元素。

map和set的区别：
1.底层实现都是红黑树，map中是键值对，set中只有键，键即是值，默认对元素进行排序和去重，默认是小根堆。
2.set不允许使用迭代器来修改键，map允许修改值不允许修改键，set中若要进行修改，首先删除，调节平衡，再插入修改后的键，再调节平衡。
3.map支持下标操作，set不支持下标操作，map下标操作中，若关键字不存在，则插入一个具有该关键字的默认元素，所以要慎用下标，如果想确定某个关键字的元素是否存在，最好用find。

unordered map底层实现是哈希表。

vector和list的区别
vector:
1.动态数组，堆上分配空间
2.扩展内存：当插入新元素时，如果内存够，则直接插入到后面，若发现原来申请的内存不够了，则另开辟一组空间，大小为原来的两倍，然后将原数组拷贝过去，将原内存释放。
3.性能：访问O(1)，插入和删除若都在最后则很快，若在中间需要进行移动（内存拷贝）操作，比较麻烦
4.适用场景：随机访问频率较高，在中间插入删除操作较少。
list:
1.底层实现是双向链表
2.每次插入新节点都会申请内存。

3.性能：访问性能较差因为只能从头开始，插入和删除性能较高，没有内存拷贝，一般是常数开销。
4.适用场景：随机访问较少，插入删除较为频繁。

resize和reserve的区别：
resize是改变当前容器中元素的数量，方法是加入足够的默认元素；reserve是改变容器的最大容量，要开辟一片新的内存，然后拷贝，析构。resize是给水桶里添水，reserve是换一个大桶，把小桶的水倒进去。

**用迭代器删除元素：
1.对于序列容器vector和deque来说使用erase(itertor)后，后边的迭代器都会失效，erase返回删除后的位置。
2.关联容器map和set，使用erase(itertor)后，当前元素迭代器会失效，但不影响其他迭代器。
3.list删除操作也不会影响其他迭代器。

C++编译：
预处理阶段：分析头文件，预编译（宏定义），生成预编译文件
编译阶段：将预编译文件进行编译生成汇编文件
汇编阶段：将汇编转化为机器码，生成目标文件
链接阶段：将多个目标文件及所需要的库连接成可执行文件（静态库需要链接进可执行文件，动态库不需要链接进可执行文件）

include尖括号和双引号的区别：
查找头文件的路径不一样：
#include<>直接从系统目录中寻找
#include""先从自定义的文件中找，找不到再从系统目录中找

io多路复用和多线程的区别
例如一个服务端连接多个客户端，需要监听多个流是否有io，多线程的做法是对于不同的流，开辟不同的线程进行监听，线程内部是阻塞的，而对于多路io复用，则通过一个代理（内核）去将所有的io集中到一个阻塞上（select,epoll,poll)进行监听，可在一个线程内处理多个io（每个io是非阻塞的）

select,poll,epoll的区别
select,poll,epoll会不断轮询所负责的文件描述符fd，当某个fd数据准备就绪时，就会通知应用进程进行io，select本身是阻塞的，调用select时，进程会被block，当有fd准备就绪时，才会返回。当连接数不多时，使用io多路复用的效率并没有使用多线程+block io模式效率更高，io多路复用适用于连接数比较多，且有较多的空闲连接。
select：用fd_set来告诉内核监听多个文件描述符
存在的问题：内置数组的形式使得select的最大文件数受限于fd_size；
轮询效率低下；
每次调用前都要初始化，调用前将fd从用户态拷到内核态，调用后将fd从内核态拷到用户态。
poll：与select并无本质区别，，只不过使用了一个可变长度数组（链表）解决了描述符受限的问题，数组元素是保存fd信息的结构体，每增加一个fd就向数组加入一个结构体，只需拷贝一次到内核态，解决了select重复初始化的问题。
epoll：在select中，只返回是否有fd状态变化，用户进程需要再做一次轮询来确定那个fd需要io，效率太低，epoll只返回状态发生变化的fd。
epoll对fd的操作有两种模式：LT（默认模式）和ET（边缘模式）。
LT模式：内核告诉用户进程哪一个fd就绪，如果不进行任何操作，内核会继续通知
ET模式：内核只会发送一次通知

fork()函数
C++中fork函数可以创建一个与父进程完全相同的子进程，将父进程的资源完全拷贝一份给子进程，父进程和子进程之间互不影响，调用fork后，父进程返回子进程的pid，子进程返回0，如果创建子进程失败则会返回负数，子进程创建后调用fork及之后的语句。

vfork()函数
采用了写时复制的fork。

exec函数族
普通的fork函数，开辟的子进程的代码与父进程是完全一样的，做的工作也是完全相同的（当然可以根据pid来写新的代码，但是代码很多的时候很麻烦且不好维护），exec函数族可以使得子进程加载新的代码来替换原有的代码，从而完成不同的功能。

写时拷贝技术：
调用fork后，系统应该为子进程开辟独立的内存空间，并将父进程复制一份给子进程，但是这样效率不高，所以采用写时拷贝技术（vfork）。在fork之后，父子进程会有不同的虚拟地址，但都指向同一块物理地址（父进程的），只有当父子进程中有更改相应段的行为发生时，才会给子进程拷贝一份并开辟独立的物理空间，至此父子进程完全独立，但是父子进程使用的代码段还是一个物理内存，当调用exec后，再为子进程的代码段开辟独立的物理空间。

wait()函数
由主进程调用，调用后阻塞，wait会分析是否有已退出的子进程，如果没有会一直等到有子进程退出并将资源完全回收避免成为僵尸进程，如果没有子进程会返回-1，主要是为了避免出现僵尸进程。

僵尸进程和孤儿进程：
僵尸进程：子进程已经终止，但是父进程未终止，子进程资源没有回收，此时子进程变为僵尸进程
孤儿进程：子进程还未结束，但是父进程已经终止，此时子进程为孤儿进程，它的资源的回收会被托管到pid=1的init进程中。